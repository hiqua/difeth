--- 
+++ 
@@ -1,15 +1,44 @@
+/*
+
+DVIP Terms of Service
+
+The following Terms of Service specify the agreement between Decentralized Capital Ltd. (DC) and the purchaser of DVIP Memberships (customer/member). By purchasing, using, or possessing the DVIP token you agree to be legally bound by these terms, which shall take effect immediately upon purchase of the membership.
+
+
+1. Rights of DVIP Membership holders: Each membership entitles the customer to ZERO transaction fees on all on-chain transfers of DC Assets, and Â½ off fees for purchasing and redeeming DC Assets through Crypto Capital. DVIP also entitles the customer to discounts on select future Decentralized Capital Ltd. services. These discounts only apply to the fees specified on the DC website. DC is not responsible for any fees charged by third parties including, but not limited to, dapps, exchanges, Crypto Capital, and Coinapult.
+
+2. DVIP membership rights expire on January 1st, 2020. Upon expiration of membership benefits, each 1/100th of a token is redeemable for an additional $1.50 in fees on eligible DC products. This additional discount expires on January 1st, 2022.
+
+3. Customers can purchase more than one membership, but only one membership can be active at a time for any one wallet. Under no circumstances are members eligible for a refund on the DVIP purchase.
+
+4. DVIP tokens are not equity in Decentralized Capital ltd. and do not give holders any power over Decentralized Capital ltd. including, but not limited to, shareholder voting, a claim on assets, or input into how Decentralized Capital ltd. is governed and managed.
+
+5. Possession of the DVIP token operates as proof of membership, and DVIP tokens can be transferred to any other wallet on Ethereum. If the DVIP token is transferred to a 3rd party, the membership benefits no longer pertain to the original party. In the event of a transfer, membership benefits will apply only AFTER a one week incubation period; any withdrawal initiated prior to the end of this incubation period will be charged the standard transaction fee. DC reserves the right to adjust the duration of the incubation period; the incubation period will never be more than one month. Changes to the DVIP balance will reset the incubation period for any DVIP that is not fully incubated. Active DVIP is not affected by balance changes.
+
+6. DVIP membership benefits are only available to individual users. Platforms such as exchanges and dapps can hold DVIP, but the transaction fee discounts specified in section 1 will not apply.
+
+7. Membership benefits are executed via the DC smart contract system; the DC membership must be held in the wallet used for DC Asset transactions in order for the discounts to apply. No transaction fees will be waived for members who receive transactions using a wallet that does not hold their DVIP tokens.
+
+8. In the event of bankruptcy: DVIP is valid until January 1st, 2020. In the event that Decentralized Capital Ltd. ceases operations, DVIP does not represent any claim on company assets nor does Decentralized Capital Ltd. have any further commitment to holders of DVIP, such as a refund on the purchase of the DVIP.
+
+9. Future Sale of DVIP: Total DVIP supply is capped at 2,000, 1,500 of which are available for purchase during this initial sale. Any DVIP not sold in the initial membership sale will be destroyed, further reducing the total supply of DVIP. The remaining 500 memberships will be sold at a later date.
+
+10. DVIP Buyback Rights: Decentralized Capital Ltd. reserves the right to repurchase the DVIP from token holders at any time. Repurchase will occur at the average price of all markets where DVIP is listed.
+
+11. Entire Agreement. The foregoing Membership Terms & Conditions contain the entire terms and agreements in connection with Member's participation in the DC service and no representations, inducements, promises or agreement, or otherwise, between DC and the Member not included herein, shall be of any force or effect. If any of the foregoing terms or provisions shall be invalid or unenforceable, the remaining terms and provisions hereof shall not be affected.
+
+12. This agreement shall be governed by and construed under, and the legal relations among the parties hereto shall be determined in accordance with, the laws of the United Kingdom of Great Britain and Northern Ireland.
+
+*/
+
 contract Assertive {
   function assert(bool assertion) {
     if (!assertion) throw;
   }
 }
 
-contract TokenRecipient {
-  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);
-}
-
 contract Owned is Assertive {
-  address internal owner;
+  address public owner;
   event SetOwner(address indexed previousOwner, address indexed newOwner);
   function Owned () {
     owner = msg.sender;
@@ -21,9 +50,6 @@
   function setOwner(address newOwner) onlyOwner {
     SetOwner(owner, newOwner);
     owner = newOwner;
-  }
-  function getOwner() returns (address out) {
-    return owner;
   }
 }
 
@@ -50,6 +76,38 @@
   function isLocked() returns (bool status) {
     return locked;
   }
+}
+
+contract TokenRecipient {
+  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);
+}
+
+contract Relay {
+  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);
+}
+
+contract TokenBase is Owned {
+    bytes32 public standard = 'Token 0.1';
+    bytes32 public name;
+    bytes32 public symbol;
+    bool public allowTransactions;
+    uint256 public totalSupply;
+
+    event Approval(address indexed from, address indexed spender, uint256 amount);
+
+    mapping (address => uint256) public balanceOf;
+    mapping (address => mapping (address => uint256)) public allowance;
+
+    event Transfer(address indexed from, address indexed to, uint256 value);
+
+    function transfer(address _to, uint256 _value) returns (bool success);
+    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);
+    function approve(address _spender, uint256 _value) returns (bool success);
+    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
+
+    function () {
+        throw;
+    }
 }
 
 contract TrustEvents {
@@ -61,10 +119,10 @@
   event NothingToCancel(address indexed from);
   event SetMasterKey(address indexed from);
   event AuthCancel(address indexed from, address indexed with);
-  event NameRegistered(address indexed from, bytes32 indexed name);
 }
 
 contract Trust is StateTransferrable, TrustEvents {
+
   mapping (address => bool) public masterKeys;
   mapping (address => bytes32) public nameRegistry;
   address[] public masterKeyIndex;
@@ -72,39 +130,103 @@
   mapping (address => bool) public trustedClients;
   mapping (uint256 => address) public functionCalls;
   mapping (address => uint256) public functionCalling;
-  function activateMasterKey(address addr) internal {
-    if (!masterKeyActive[addr]) {
-      masterKeyActive[addr] = true;
-      masterKeyIndex.push(addr);
-    }
-  }
-  function setTrustedClient(address addr) onlyOwnerUnlocked setter {
-    trustedClients[addr] = true;
-  }
-  function untrustClient(address addr) multisig(sha3(msg.data)) {
-    trustedClients[addr] = false;
-  }
-  function trustClient(address addr) multisig(sha3(msg.data)) {
-    trustedClients[addr] = true;
-  }
+
+  /* ---------------  modifiers  --------------*/
+
+  modifier multisig (bytes32 hash) {
+    if (!masterKeys[msg.sender]) {
+      Unauthorized(msg.sender);
+    } else if (functionCalling[msg.sender] == 0) {
+      if (functionCalls[uint256(hash)] == 0x0) {
+        functionCalls[uint256(hash)] = msg.sender;
+        functionCalling[msg.sender] = uint256(hash);
+        AuthInit(msg.sender);
+      } else {
+        AuthComplete(functionCalls[uint256(hash)], msg.sender);
+        resetAction(uint256(hash));
+        _
+      }
+    } else {
+      AuthPending(msg.sender);
+    }
+  }
+
+  /* ---------------  setter methods, only for the unlocked state --------------*/
+
+  /**
+   * @notice Sets a master key
+   *
+   * @param addr Address
+   */
   function setMasterKey(address addr) onlyOwnerUnlocked {
     assert(!masterKeys[addr]);
     activateMasterKey(addr);
     masterKeys[addr] = true;
     SetMasterKey(msg.sender);
   }
-  modifier onlyMasterKey {
-    assert(masterKeys[msg.sender]);
-    _
-  }
-  function extractMasterKeyIndexLength() returns (uint256 length) {
-    return masterKeyIndex.length;
-  }
-  function resetAction(uint256 hash) internal {
-    address addr = functionCalls[hash];
-    functionCalls[hash] = 0x0;
-    functionCalling[addr] = 0;
-  }
+
+  /**
+   * @notice Adds a trusted client
+   *
+   * @param addr Address
+   */
+  function setTrustedClient(address addr) onlyOwnerUnlocked setter {
+    trustedClients[addr] = true;
+  }
+
+  /* ---------------  methods to be called by a Master Key  --------------*/
+
+
+
+  /* ---------------  multisig admin methods  --------------*/
+
+  /**
+   * @notice remove contract `addr` from the list of trusted contracts
+   *
+   * @param addr Address of client contract to be removed
+   */
+  function untrustClient(address addr) multisig(sha3(msg.data)) {
+    trustedClients[addr] = false;
+  }
+
+  /**
+   * @notice add contract `addr` to the list of trusted contracts
+   *
+   * @param addr Address of contract to be added
+   */
+  function trustClient(address addr) multisig(sha3(msg.data)) {
+    trustedClients[addr] = true;
+  }
+
+  /**
+   * @notice remove key `addr` to the list of master keys
+   *
+   * @param addr Address of the masterkey
+   */
+  function voteOutMasterKey(address addr) multisig(sha3(msg.data)) {
+    assert(masterKeys[addr]);
+    masterKeys[addr] = false;
+  }
+
+  /**
+   * @notice add key `addr` to the list of master keys
+   *
+   * @param addr Address of the masterkey
+   */
+  function voteInMasterKey(address addr) multisig(sha3(msg.data)) {
+    assert(!masterKeys[addr]);
+    activateMasterKey(addr);
+    masterKeys[addr] = true;
+  }
+
+  /* ---------------  methods to be called by Trusted Client Contracts  --------------*/
+
+
+  /**
+   * @notice Cancel outstanding multisig method call from address `from`. Called from trusted clients.
+   *
+   * @param from Address that issued the call that needs to be cancelled
+   */
   function authCancel(address from) external returns (uint8 status) {
     if (!masterKeys[from] || !trustedClients[msg.sender]) {
       Unauthorized(from);
@@ -121,6 +243,41 @@
       return 2;
     }
   }
+
+  /**
+   * @notice Authorize multisig call on a trusted client. Called from trusted clients.
+   *
+   * @param from Address from which call is made.
+   * @param hash of method call
+   */
+  function authCall(address from, bytes32 hash) external returns (uint8 code) {
+    if (!masterKeys[from] || !trustedClients[msg.sender]) {
+      Unauthorized(from);
+      return 0;
+    }
+    if (functionCalling[from] == 0) {
+      if (functionCalls[uint256(hash)] == 0x0) {
+        functionCalls[uint256(hash)] = from;
+        functionCalling[from] = uint256(hash);
+        AuthInit(from);
+        return 1;
+      } else {
+        AuthComplete(functionCalls[uint256(hash)], from);
+        resetAction(uint256(hash));
+        return 2;
+      }
+    } else {
+      AuthPending(from);
+      return 3;
+    }
+  }
+
+  /* ---------------  methods to be called directly on the contract --------------*/
+
+  /**
+   * @notice cancel any outstanding multisig call
+   *
+   */
   function cancel() returns (uint8 code) {
     if (!masterKeys[msg.sender]) {
       Unauthorized(msg.sender);
@@ -138,79 +295,35 @@
       return 2;
     }
   }
-  function authCall(address from, bytes32 hash) external returns (uint8 code) {
-    if (!masterKeys[from] && !trustedClients[msg.sender]) {
-      Unauthorized(from);
-      return 0;
-    }
-    if (functionCalling[from] == 0) {
-      if (functionCalls[uint256(hash)] == 0x0) {
-        functionCalls[uint256(hash)] = from;
-        functionCalling[from] = uint256(hash);
-        AuthInit(from);
-        return 1;
-      } else { 
-        AuthComplete(functionCalls[uint256(hash)], from);
-        resetAction(uint256(hash));
-        return 2;
-      }
-    } else {
-      AuthPending(from);
-      return 3;
-    }
-  }
-  modifier multisig (bytes32 hash) {
-    if (!masterKeys[msg.sender]) {
-      Unauthorized(msg.sender);
-    } else if (functionCalling[msg.sender] == 0) {
-      if (functionCalls[uint256(hash)] == 0x0) {
-        functionCalls[uint256(hash)] = msg.sender;
-        functionCalling[msg.sender] = uint256(hash);
-        AuthInit(msg.sender);
-      } else { 
-        AuthComplete(functionCalls[uint256(hash)], msg.sender);
-        resetAction(uint256(hash));
-        _
-      }
-    } else {
-      AuthPending(msg.sender);
-    }
-  }
-  function voteOutMasterKey(address addr) multisig(sha3(msg.data)) {
-    assert(masterKeys[addr]);
-    masterKeys[addr] = false;
-  }
-  function voteInMasterKey(address addr) multisig(sha3(msg.data)) {
-    assert(!masterKeys[addr]);
-    activateMasterKey(addr);
-    masterKeys[addr] = true;
-  }
-  function identify(bytes32 name) onlyMasterKey {
-    nameRegistry[msg.sender] = name;
-    NameRegistered(msg.sender, name);
-  }
-  function nameFor(address addr) returns (bytes32 name) {
-    return nameRegistry[addr];
-  }
+
+  /* ---------------  private methods --------------*/
+
+  function resetAction(uint256 hash) internal {
+    address addr = functionCalls[hash];
+    functionCalls[hash] = 0x0;
+    functionCalling[addr] = 0;
+  }
+
+  function activateMasterKey(address addr) internal {
+    if (!masterKeyActive[addr]) {
+      masterKeyActive[addr] = true;
+      masterKeyIndex.push(addr);
+    }
+  }
+
+  /* ---------------  helper methods for siphoning --------------*/
+
+  function extractMasterKeyIndexLength() returns (uint256 length) {
+    return masterKeyIndex.length;
+  }
+
 }
 
 
 contract TrustClient is StateTransferrable, TrustEvents {
+
   address public trustAddress;
-  function setTrust(address addr) setter onlyOwnerUnlocked {
-    trustAddress = addr;
-  }
-  function nameFor(address addr) constant returns (bytes32 name) {
-    return Trust(trustAddress).nameFor(addr);
-  }
-  function cancel() returns (uint8 status) {
-    assert(trustAddress != address(0x0));
-    uint8 code = Trust(trustAddress).authCancel(msg.sender);
-    if (code == 0) Unauthorized(msg.sender);
-    else if (code == 1) NothingToCancel(msg.sender);
-    else if (code == 2) AuthCancel(msg.sender, msg.sender);
-    return code;
-  }
+
   modifier multisig (bytes32 hash) {
     assert(trustAddress != address(0x0));
     address current = Trust(trustAddress).functionCalls(uint256(hash));
@@ -225,246 +338,146 @@
       AuthPending(msg.sender);
     }
   }
-}
-contract Relay {
-  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);
-}
-contract TokenBase is Owned {
-    bytes32 public standard = 'Token 0.1';
-    bytes32 public name;
-    bytes32 public symbol;
-    uint256 public totalSupply;
-    bool public allowTransactions;
-
-    event Approval(address indexed from, address indexed spender, uint256 amount);
-
-    mapping (address => uint256) public balanceOf;
-    mapping (address => mapping (address => uint256)) public allowance;
-
-    event Transfer(address indexed from, address indexed to, uint256 value);
-
-    function transfer(address _to, uint256 _value) returns (bool success);
-    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);
-    function approve(address _spender, uint256 _value) returns (bool success);
-    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
-
-    function () {
-        throw;
-    }
-}
-
-contract Precision {
+  
+  function setTrust(address addr) setter onlyOwnerUnlocked {
+    trustAddress = addr;
+  }
+
+  function cancel() returns (uint8 status) {
+    assert(trustAddress != address(0x0));
+    uint8 code = Trust(trustAddress).authCancel(msg.sender);
+    if (code == 0) Unauthorized(msg.sender);
+    else if (code == 1) NothingToCancel(msg.sender);
+    else if (code == 2) AuthCancel(msg.sender, msg.sender);
+    return code;
+  }
+
+}
+
+contract DVIPBackend {
   uint8 public decimals;
-}
-contract Token is TokenBase, Precision {}
-contract Util {
-  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {
-    for (uint8 i = 0; i < b; i++) {
-      a *= 10;
-    }
-    return a;
-  }
-  function div10(uint256 a, uint8 b) internal returns (uint256 result) {
-    for (uint8 i = 0; i < b; i++) {
-      a /= 10;
-    }
-    return a;
-  }
-  function max(uint256 a, uint256 b) internal returns (uint256 res) {
-    if (a >= b) return a;
-    return b;
-  }
-}
-
-/**
- * @title DVIP Contract. DCAsset Membership Token contract.
- *
- * @author Ray Pulver, ray@decentralizedcapital.com
- */
-contract DVIP is Token, StateTransferrable, TrustClient, Util {
-
+  function assert(bool assertion) {
+    if (!assertion) throw;
+  }
+  bytes32 public standard = 'Token 0.1';
+  bytes32 public name;
+  bytes32 public symbol;
+  bool public allowTransactions;
   uint256 public totalSupply;
 
+  event Approval(address indexed from, address indexed spender, uint256 amount);
+  event PropertySet(address indexed from);
+
+  mapping (address => uint256) public balanceOf;
+  mapping (address => mapping (address => uint256)) public allowance;
+
+/*
+  mapping (address => bool) public balanceOfActive;
+  address[] public balanceOfIndex;
+*/
+
+/*
+  mapping (address => bool) public allowanceActive;
+  address[] public allowanceIndex;
+
+  mapping (address => mapping (address => bool)) public allowanceRecordActive;
+  mapping (address => address[]) public allowanceRecordIndex;
+*/
+
+  event Transfer(address indexed from, address indexed to, uint256 value);
+
+  uint256 public baseFeeDivisor;
+  uint256 public feeDivisor;
+  uint256 public singleDVIPQty;
+
+  function () {
+    throw;
+  }
+
+  bool public locked;
+  address public owner;
+
+  modifier onlyOwnerUnlocked {
+    assert(msg.sender == owner && !locked);
+    _
+  }
+
+  modifier onlyOwner {
+    assert(msg.sender == owner);
+    _
+  }
+
+  function lock() onlyOwnerUnlocked returns (bool success) {
+    locked = true;
+    PropertySet(msg.sender);
+    return true;
+  }
+
+  function setOwner(address _address) onlyOwner returns (bool success) {
+    owner = _address;
+    PropertySet(msg.sender);
+    return true;
+  }
+
+  uint256 public expiry;
+  uint8 public feeDecimals;
+
+  struct Validity {
+    uint256 last;
+    uint256 ts;
+  }
+
+  mapping (address => Validity) public validAfter;
+  uint256 public mustHoldFor;
+  address public hotwalletAddress;
+  address public frontendAddress;
   mapping (address => bool) public frozenAccount;
-
-  mapping (address => address[]) public allowanceIndex;
-  mapping (address => mapping (address => bool)) public allowanceActive;
-  address[] public accountIndex;
-  mapping (address => bool) public accountActive;
-  address public oversightAddress;
-  uint256 public expiry;
-
-  uint256 public treasuryBalance;
-
-  bool public isActive;
+/*
+  mapping (address => bool) public frozenAccountActive;
+  address[] public frozenAccountIndex;
+*/
   mapping (address => uint256) public exportFee;
+/*
+  mapping (address => bool) public exportFeeActive;
   address[] public exportFeeIndex;
-  mapping (address => bool) exportFeeActive;
-
-  mapping (address => uint256) public importFee;
-  address[] public importFeeIndex;
-  mapping (address => bool) importFeeActive;
-
-  event FrozenFunds(address target, bool frozen);
-  event PrecisionSet(address indexed from, uint8 precision);
-  event TransactionsShutDown(address indexed from);
+*/
+
   event FeeSetup(address indexed from, address indexed target, uint256 amount);
-
+  event Processed(address indexed sender);
+
+  modifier onlyAsset {
+    if (msg.sender != frontendAddress) throw;
+    _
+  }
 
   /**
    * Constructor.
    *
    */
-  function DVIP() {
-    isActive = true;
-    treasuryBalance = 0;
+  function DVIPBackend(address _hotwalletAddress, address _frontendAddress) {
+    owner = msg.sender;
+    hotwalletAddress = _hotwalletAddress;
+    frontendAddress = _frontendAddress;
+    allowTransactions = true;
     totalSupply = 0;
     name = "DVIP";
     symbol = "DVIP";
-    decimals = 6;
-    allowTransactions = true;
+    feeDecimals = 6;
+    decimals = 1;
     expiry = 1514764800; //1 jan 2018
-  }
-
-
-  /* ---------------  modifiers  --------------*/
-
-  /**
-   * Makes sure a method is only called by an overseer.
-   */
-  modifier onlyOverseer {
-    assert(msg.sender == oversightAddress);
-    _
-  }
-
-  /* ---------------  setter methods, only for the unlocked state --------------*/
-
-
-  /**
-   * Sets the oversight address (not the contract).
-   *
-   * @param addr The oversight contract address.
-   */
-  function setOversight(address addr) onlyOwnerUnlocked setter {
-    oversightAddress = addr;
-  }
-
-
-  /**
-   * Sets the total supply
-   *
-   * @param total Total supply of the asset.
-   */
-  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {
-    totalSupply = total;
-  }
-
-  /**
-   * Set the Token Standard the contract applies to.
-   *
-   * @param std the Standard.
-   */
-  function setStandard(bytes32 std) onlyOwnerUnlocked setter {
-    standard = std;
-  }
-
-  /**
-   * Sets the name of the contraxt
-   *
-   * @param _name the name.
-   */
-  function setName(bytes32 _name) onlyOwnerUnlocked setter {
-    name = _name;
-  }
-
-  /**
-   * Sets the symbol
-   *
-   * @param sym The Symbol
-   */
-  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {
-    symbol = sym;
-  }
-
-  /**
-   * Sets the precision
-   *
-   * @param precision Amount of decimals
-   */
-  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {
-    decimals = precision;
-    PrecisionSet(msg.sender, precision);
-  }
-
-  /**
-   * Sets the balance of a certain account.
-   *
-   * @param addr Address of the account
-   * @param amount Amount of assets to set on the account
-   */
-  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {
-    balanceOf[addr] = amount;
-    activateAccount(addr);
-  }
-
-  /**
-   * Sets an allowance from a specific account to a specific account.
-   *
-   * @param from From-part of the allowance
-   * @param to To-part of the allowance
-   * @param amount Amount of the allowance
-   */
-  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {
-    allowance[from][to] = amount;
-    activateAllowanceRecord(from, to);
-  }
-
-  /**
-   * Sets the treasure balance to a certain account.
-   *
-   * @param amount Amount of assets to pre-set in the treasury
-   */
-  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {
-    treasuryBalance = amount;
-  }
-
-  /**
-   * Sets a certain account on frozen/unfrozen
-   *
-   * @param addr Account that will be frozen/unfrozen
-   * @param frozen Boolean to freeze or unfreeze
-   */
-  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {
-    activateAccount(addr);
-    frozenAccount[addr] = frozen;
-  }
-
-  /**
-   * Sets up a import fee for a certain address.
-   *
-   * @param addr Address that will require fee
-   * @param fee Amount of fee
-   */
-  function setupImportFee(address addr, uint256 fee) onlyOwnerUnlocked {
-    importFee[addr] = fee;
-    activateImportFeeChargeRecord(addr);
-    FeeSetup(msg.sender, addr, fee);
-  }
- 
-  /**
-   * Sets up a export fee for a certain address.
-   *
-   * @param addr Address that will require fee
-   * @param fee Amount of fee
-   */
-  function setupExportFee(address addr, uint256 fee) onlyOwnerUnlocked {
-    exportFee[addr] = fee;
-    activateExportFeeChargeRecord(addr);
-    FeeSetup(msg.sender, addr, fee);
-  }
-
-  /* ---------------  main token methods  --------------*/
-
+    mustHoldFor = 604800;
+    precalculate();
+  }
+
+  function setHotwallet(address _address) onlyOwnerUnlocked {
+    hotwalletAddress = _address;
+    PropertySet(msg.sender);
+  }
+
+  function setFrontend(address _address) onlyOwnerUnlocked {
+    frontendAddress = _address;
+    PropertySet(msg.sender);
+  } 
 
   /**
    * @notice Transfer `_amount` from `msg.sender.address()` to `_to`.
@@ -472,17 +485,24 @@
    * @param _to Address that will receive.
    * @param _amount Amount to be transferred.
    */
-  function transfer(address _to, uint256 _amount) returns (bool success) {
+  function transfer(address caller, address _to, uint256 _amount) onlyAsset returns (bool success) {
     assert(allowTransactions);
-    assert(!frozenAccount[msg.sender]);
-    assert(balanceOf[msg.sender] >= _amount);
+    assert(balanceOf[caller] >= _amount);
     assert(balanceOf[_to] + _amount >= balanceOf[_to]);
-    activateAccount(msg.sender);
-    activateAccount(_to);
-    balanceOf[msg.sender] -= _amount;
-    if (_to == address(this)) treasuryBalance += _amount;
-    else balanceOf[_to] += _amount;
-    Transfer(msg.sender, _to, _amount);
+    assert(!frozenAccount[caller]);
+    assert(!frozenAccount[_to]);
+    balanceOf[caller] -= _amount;
+    // activateBalance(caller);
+    // activateBalance(_to);
+    uint256 preBalance = balanceOf[_to];
+    balanceOf[_to] += _amount;
+    bool alreadyMax = preBalance >= singleDVIPQty;
+    if (!alreadyMax) {
+      if (now >= validAfter[_to].ts + mustHoldFor) validAfter[_to].last = preBalance;
+      validAfter[_to].ts = now;
+    }
+    if (validAfter[caller].last > balanceOf[caller]) validAfter[caller].last = balanceOf[caller];
+    Transfer(caller, _to, _amount);
     return true;
   }
 
@@ -494,19 +514,26 @@
    * @param _amount Amount to be transferred.
    * @return result of the method call
    */
-  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {
+  function transferFrom(address caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {
     assert(allowTransactions);
-    assert(!frozenAccount[msg.sender]);
-    assert(!frozenAccount[_from]);
     assert(balanceOf[_from] >= _amount);
     assert(balanceOf[_to] + _amount >= balanceOf[_to]);
-    assert(_amount <= allowance[_from][msg.sender]);
+    assert(_amount <= allowance[_from][caller]);
+    assert(!frozenAccount[caller]);
+    assert(!frozenAccount[_from]);
+    assert(!frozenAccount[_to]);
     balanceOf[_from] -= _amount;
+    uint256 preBalance = balanceOf[_to];
     balanceOf[_to] += _amount;
-    allowance[_from][msg.sender] -= _amount;
-    activateAccount(_from);
-    activateAccount(_to);
-    activateAccount(msg.sender);
+    // activateBalance(_from);
+    // activateBalance(_to);
+    allowance[_from][caller] -= _amount;
+    bool alreadyMax = preBalance >= singleDVIPQty;
+    if (!alreadyMax) {
+      if (now >= validAfter[_to].ts + mustHoldFor) validAfter[_to].last = preBalance;
+      validAfter[_to].ts = now;
+    }
+    if (validAfter[_from].last > balanceOf[_from]) validAfter[_from].last = balanceOf[_from];
     Transfer(_from, _to, _amount);
     return true;
   }
@@ -519,16 +546,12 @@
    * @param _extraData Consequential contract to be executed by spender in same transcation.
    * @return result of the method call
    */
-  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {
+  function approveAndCall(address caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {
     assert(allowTransactions);
-    assert(!frozenAccount[msg.sender]);
-    allowance[msg.sender][_spender] = _amount;
-    activateAccount(msg.sender);
-    activateAccount(_spender);
-    activateAllowanceRecord(msg.sender, _spender);
-    TokenRecipient spender = TokenRecipient(_spender);
-    spender.receiveApproval(msg.sender, _amount, this, _extraData);
-    Approval(msg.sender, _spender, _amount);
+    allowance[caller][_spender] = _amount;
+    // activateAllowance(caller, _spender);
+    Relay(frontendAddress).relayReceiveApproval(caller, _spender, _amount, _extraData);
+    Approval(caller, _spender, _amount);
     return true;
   }
 
@@ -539,14 +562,11 @@
    * @param _amount Amount on the cheque
    * @return result of the method call
    */
-  function approve(address _spender, uint256 _amount) returns (bool success) {
+  function approve(address caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {
     assert(allowTransactions);
-    assert(!frozenAccount[msg.sender]);
-    allowance[msg.sender][_spender] = _amount;
-    activateAccount(msg.sender);
-    activateAccount(_spender);
-    activateAllowanceRecord(msg.sender, _spender);
-    Approval(msg.sender, _spender, _amount);
+    allowance[caller][_spender] = _amount;
+    // activateAllowance(caller, _spender);
+    Approval(caller, _spender, _amount);
     return true;
   }
 
@@ -560,8 +580,9 @@
    * @param ts milliseconds since 1970.
    *
    */
-  function setExpiry(uint256 ts) multisig(sha3(msg.data)) {
+  function setExpiry(uint256 ts) onlyOwner {
     expiry = ts;
+    Processed(msg.sender);
   }
 
   /**
@@ -569,116 +590,57 @@
    *
    * @param mintedAmount Amount of new tokens to be minted.
    */
-  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {
-    treasuryBalance += mintedAmount;
+  function mint(uint256 mintedAmount) onlyOwner {
+    balanceOf[hotwalletAddress] += mintedAmount;
+   // activateBalance(hotwalletAddress);
     totalSupply += mintedAmount;
-  }
-
-  /**
-   * @notice Destroys `destroyAmount` new tokens from the hotwallet `hotWalletAddress`
-   *
-   * @param destroyAmount Amount of new tokens to be minted.
-   */
-  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {
-    assert(treasuryBalance >= destroyAmount);
-    treasuryBalance -= destroyAmount;
-    totalSupply -= destroyAmount;
-  }
-
-  /**
-   * @notice Transfers `amount` from the treasury to `to`
-   *
-   * @param to Address to transfer to
-   * @param amount Amount to transfer from treasury
-   */
-  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {
-    assert(treasuryBalance >= amount);
-    treasuryBalance -= amount;
-    balanceOf[to] += amount;
-    activateAccount(to);
-  }
-
-  /* ---------------  fee setting administration methods  --------------*/
-
-  /**
-   * @notice Sets an import fee of `fee` on address `addr`
+    Processed(msg.sender);
+  }
+
+  function freezeAccount(address target, bool frozen) onlyOwner {
+    frozenAccount[target] = frozen;
+    // activateFrozenAccount(target);
+    Processed(msg.sender);
+  }
+
+  function seizeTokens(address target, uint256 amount) onlyOwner {
+    assert(balanceOf[target] >= amount);
+    assert(frozenAccount[target]);
+    balanceOf[target] -= amount;
+    balanceOf[hotwalletAddress] += amount;
+    Transfer(target, hotwalletAddress, amount);
+  }
+
+  function destroyTokens(uint256 amt) onlyOwner {
+    assert(balanceOf[hotwalletAddress] >= amt);
+    balanceOf[hotwalletAddress] -= amt;
+    Processed(msg.sender);
+  }
+
+  /**
+   * @notice Sets an export fee of `fee` on address `addr`
    *
    * @param addr Address for which the fee is valid
    * @param addr fee Fee
    *
    */
-  function setImportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {
-    uint256 max = 1;
-    max = pow10(1, decimals);
-    assert(fee <= max);
-    importFee[addr] = fee;
-    activateImportFeeChargeRecord(addr);
-  }
-
-  /**
-   * @notice Sets an export fee of `fee` on address `addr`
-   *
-   * @param addr Address for which the fee is valid
-   * @param addr fee Fee
-   *
-   */
-  function setExportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {
-    uint256 max = 1;
-    max = pow10(1, decimals);
-    assert(fee <= max);
+  function setExportFee(address addr, uint256 fee) onlyOwner {
     exportFee[addr] = fee;
-    activateExportFeeChargeRecord(addr);
-  }
-
-
-  /* ---------------  multisig emergency methods --------------*/
-
-  /**
-   * @notice Sets allow transactions to `allow`
-   *
-   * @param allow Allow or disallow transactions
-   */
-  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {
-    assert(allow != allowTransactions);
+   // activateExportFee(addr);
+    Processed(msg.sender);
+  }
+
+  function setHoldingPeriod(uint256 ts) onlyOwner {
+    mustHoldFor = ts;
+    Processed(msg.sender);
+  }
+
+  function setAllowTransactions(bool allow) onlyOwner {
     allowTransactions = allow;
-  }
-
-  /**
-   * @notice Destructs the contract and sends remaining `this.balance` Ether to `beneficiary`
-   *
-   * @param beneficiary Beneficiary of remaining Ether on contract
-   */
-  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {
-    selfdestruct(beneficiary);
-  }
-
-  /**
-   * @notice Sets frozen to `freeze` for account `target`
-   *
-   * @param addr Address to be frozen/unfrozen
-   * @param freeze Freeze/unfreeze account
-   */
-  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {
-    frozenAccount[addr] = freeze;
-    activateAccount(addr);
-  }
-
-  /**
-   * @notice Seizes `seizeAmount` of tokens from `address` and transfers it to hotwallet
-   *
-   * @param addr Adress to seize tokens from
-   * @param amount Amount of tokens to seize
-   */
-  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {
-    assert(balanceOf[addr] >= amount);
-    assert(frozenAccount[addr]);
-    activateAccount(addr);
-    balanceOf[addr] -= amount;
-    treasuryBalance += amount;
+    Processed(msg.sender);
   }
 
   /* --------------- fee calculation method ---------------- */
-
 
   /**
    * @notice 'Returns the fee for a transfer from `from` to `to` on an amount `amount`.
@@ -699,523 +661,88 @@
    *
    */
   function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {
-    uint256 fee = exportFee[from] + importFee[to];
+    uint256 fee = exportFee[from];
     if (fee == 0) return 0;
+    if (now >= expiry) return amount*fee / baseFeeDivisor;
     uint256 amountHeld;
-    bool discounted = true;
-    uint256 oneDVIPUnit;
-    if (exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry) {
-      amountHeld = balanceOf[from];
-    } else if (importFee[to] == 0 && balanceOf[to] != 0 && now < expiry) {
-      amountHeld = balanceOf[to];
-    } else discounted = false;
-    if (discounted) {
-      oneDVIPUnit = pow10(1, decimals);
-      if (amountHeld > oneDVIPUnit) amountHeld = oneDVIPUnit;
-      uint256 remaining = oneDVIPUnit - amountHeld;
-      return div10(amount*fee*remaining, decimals*2);
-    }
-    return div10(amount*fee, decimals);
-  }
-
-
-  /* ---------------  overseer methods for emergency --------------*/
-
-  /**
-   * @notice Shuts down all transaction and approval options on the asset contract
-   */
-  function shutdownTransactions() onlyOverseer {
-    allowTransactions = false;
-    TransactionsShutDown(msg.sender);
-  }
-
-  /* ---------------  helper methods for siphoning --------------*/
-
-  function extractAccountAllowanceRecordLength(address addr) constant returns (uint256 len) {
-    return allowanceIndex[addr].length;
-  }
-
-  function extractAccountLength() constant returns (uint256 length) {
-    return accountIndex.length;
-  }
-
-  /* ---------------  private methods --------------*/
-
-  function activateAccount(address addr) internal {
-    if (!accountActive[addr]) {
-      accountActive[addr] = true;
-      accountIndex.push(addr);
-    }
-  }
-
-  function activateAllowanceRecord(address from, address to) internal {
-    if (!allowanceActive[from][to]) {
-      allowanceActive[from][to] = true;
-      allowanceIndex[from].push(to);
-    }
-  }
-
-  function activateExportFeeChargeRecord(address addr) internal {
-    if (!exportFeeActive[addr]) {
-      exportFeeActive[addr] = true;
-      exportFeeIndex.push(addr);
-    }
-  }
-
-  function activateImportFeeChargeRecord(address addr) internal {
-    if (!importFeeActive[addr]) {
-      importFeeActive[addr] = true;
-      importFeeIndex.push(addr);
-    }
-  }
-  function extractImportFeeChargeLength() returns (uint256 length) {
-    return importFeeIndex.length;
-  }
-
-  function extractExportFeeChargeLength() returns (uint256 length) {
+    if (balanceOf[to] != 0) {
+      if (validAfter[to].ts + mustHoldFor < now) amountHeld = balanceOf[to];
+      else amountHeld = validAfter[to].last;
+      if (amountHeld >= singleDVIPQty) return 0;
+      return amount*fee*(singleDVIPQty - amountHeld) / feeDivisor;
+    } else return amount*fee / baseFeeDivisor;
+  }
+  function precalculate() internal returns (bool success) {
+    baseFeeDivisor = pow10(1, feeDecimals);
+    feeDivisor = pow10(1, feeDecimals + decimals);
+    singleDVIPQty = pow10(1, decimals);
+  }
+  function div10(uint256 a, uint8 b) internal returns (uint256 result) {
+    for (uint8 i = 0; i < b; i++) {
+      a /= 10;
+    }
+    return a;
+  }
+  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {
+    for (uint8 i = 0; i < b; i++) {
+      a *= 10;
+    }
+    return a;
+  }
+  /*
+  function activateBalance(address address_) internal {
+    if (!balanceOfActive[address_]) {
+      balanceOfActive[address_] = true;
+      balanceOfIndex.push(address_);
+    }
+  }
+  function activateFrozenAccount(address address_) internal {
+    if (!frozenAccountActive[address_]) {
+      frozenAccountActive[address_] = true;
+      frozenAccountIndex.push(address_);
+    }
+  }
+  function activateAllowance(address from, address to) internal {
+    if (!allowanceActive[from]) {
+      allowanceActive[from] = true;
+      allowanceIndex.push(from);
+    }
+    if (!allowanceRecordActive[from][to]) {
+      allowanceRecordActive[from][to] = true;
+      allowanceRecordIndex[from].push(to);
+    }
+  }
+  function activateExportFee(address address_) internal {
+    if (!exportFeeActive[address_]) {
+      exportFeeActive[address_] = true;
+      exportFeeIndex.push(address_);
+    }
+  }
+  function extractBalanceOfLength() constant returns (uint256 length) {
+    return balanceOfIndex.length;
+  }
+  function extractAllowanceLength() constant returns (uint256 length) {
+    return allowanceIndex.length;
+  }
+  function extractAllowanceRecordLength(address from) constant returns (uint256 length) {
+    return allowanceRecordIndex[from].length;
+  }
+  function extractFrozenAccountLength() constant returns (uint256 length) {
+    return frozenAccountIndex.length;
+  }
+  function extractFeeLength() constant returns (uint256 length) {
     return exportFeeIndex.length;
   }
+  */
 }
 
 /**
- * @title DCAssetBackend Contract
+ * @title DVIP
  *
- * @author Ray Pulver, ray@decentralizedcapital.com
- */
-contract DCAssetBackend is Owned, Precision, StateTransferrable, TrustClient, Util {
-
-  bytes32 public standard = 'Token 0.1';
-  bytes32 public name;
-  bytes32 public symbol;
-
-  bool public allowTransactions;
-
-  event Approval(address indexed from, address indexed spender, uint256 amount);
-
-  mapping (address => uint256) public balanceOf;
-  mapping (address => mapping (address => uint256)) public allowance;
-
-  event Transfer(address indexed from, address indexed to, uint256 value);
-
-  uint256 public totalSupply;
-
-  address public hotWalletAddress;
-  address public assetAddress;
-  address public oversightAddress;
-  address public membershipAddress;
-
-  mapping (address => bool) public frozenAccount;
-
-  mapping (address => address[]) public allowanceIndex;
-  mapping (address => mapping (address => bool)) public allowanceActive;
-  address[] public accountIndex;
-  mapping (address => bool) public accountActive;
-
-  bool public isActive;
-  uint256 public treasuryBalance;
-
-  mapping (address => uint256) public feeCharge;
-  address[] public feeChargeIndex;
-  mapping (address => bool) feeActive;
-
-  event FrozenFunds(address target, bool frozen);
-  event PrecisionSet(address indexed from, uint8 precision);
-  event TransactionsShutDown(address indexed from);
-  event FeeSetup(address indexed from, address indexed target, uint256 amount);
-
-
-  /**
-   * Constructor.
-   *
-   * @param tokenName Name of the Token
-   * @param tokenSymbol The Token Symbol
-   */
-  function DCAssetBackend(bytes32 tokenSymbol, bytes32 tokenName) {
-    isActive = true;
-    name = tokenName;
-    symbol = tokenSymbol;
-    decimals = 6;
-    allowTransactions = true;
-  }
-
-  /* ---------------  modifiers  --------------*/
-
-  /**
-   * Makes sure a method is only called by an overseer.
-   */
-  modifier onlyOverseer {
-    assert(msg.sender == oversightAddress);
-    _
-  }
-
-  /**
-   * Make sure only the front end Asset can call the transfer methods
-   */
-   modifier onlyAsset {
-    assert(msg.sender == assetAddress);
-    _
-   }
-
-  /* ---------------  setter methods, only for the unlocked state --------------*/
-
-
-  /**
-   * Sets the hot wallet contract address
-   *
-   * @param addr Address of the Hotwallet
-   */
-  function setHotWallet(address addr) onlyOwnerUnlocked setter {
-    hotWalletAddress = addr;
-  }
-
-  /**
-    * Sets the token facade contract address
-    *
-    * @param addr Address of the front-end Asset
-    */
-  function setAsset(address addr) onlyOwnerUnlocked setter {
-    assetAddress = addr;
-  }
-
-  /**
-   * Sets the membership contract address
-   *
-   * @param addr Address of the membership contract
-   */
-  function setMembership(address addr) onlyOwnerUnlocked setter {
-    membershipAddress = addr;
-  }
-
-  /**
-   * Sets the oversight address (not the contract).
-   *
-   * @param addr The oversight contract address.
-   */
-  function setOversight(address addr) onlyOwnerUnlocked setter {
-    oversightAddress = addr;
-  }
-
-  /**
-   * Sets the total supply
-   *
-   * @param total Total supply of the asset.
-   */
-  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {
-    totalSupply = total;
-  }
-
-  /**
-   * Set the Token Standard the contract applies to.
-   *
-   * @param std the Standard.
-   */
-  function setStandard(bytes32 std) onlyOwnerUnlocked setter {
-    standard = std;
-  }
-
-  /**
-   * Sets the name of the contraxt
-   *
-   * @param _name the name.
-   */
-  function setName(bytes32 _name) onlyOwnerUnlocked setter {
-    name = _name;
-  }
-
-  /**
-   * Sets the symbol
-   *
-   * @param sym The Symbol
-   */
-  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {
-    symbol = sym;
-  }
-
-  /**
-   * Sets the precision
-   *
-   * @param precision Amount of decimals
-   */
-  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {
-    decimals = precision;
-    PrecisionSet(msg.sender, precision);
-  }
-
-  /**
-   * Sets the balance of a certain account.
-   *
-   * @param addr Address of the account
-   * @param amount Amount of assets to set on the account
-   */
-  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {
-    balanceOf[addr] = amount;
-    activateAccount(addr);
-  }
-
-  /**
-   * Sets an allowance from a specific account to a specific account.
-   *
-   * @param from From-part of the allowance
-   * @param to To-part of the allowance
-   * @param amount Amount of the allowance
-   */
-  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {
-    allowance[from][to] = amount;
-    activateAllowanceRecord(from, to);
-  }
-
-  /**
-   * Sets the treasure balance to a certain account.
-   *
-   * @param amount Amount of assets to pre-set in the treasury
-   */
-  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {
-    treasuryBalance = amount;
-  }
-
-  /**
-   * Sets a certain account on frozen/unfrozen
-   *
-   * @param addr Account that will be frozen/unfrozen
-   * @param frozen Boolean to freeze or unfreeze
-   */
-  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {
-    activateAccount(addr);
-    frozenAccount[addr] = frozen;
-  }
-
-  /* ---------------  main token methods  --------------*/
-
-
-  /**
-   * @notice Transfer `_amount` from `_caller` to `_to`.
-   *
-   * @param _caller Origin address
-   * @param _to Address that will receive.
-   * @param _amount Amount to be transferred.
-   */
-  function transfer(address _caller, address _to, uint256 _amount) onlyAsset returns (bool success) {
-    assert(allowTransactions);
-    assert(!frozenAccount[_caller]);
-    assert(balanceOf[_caller] >= _amount);
-    assert(balanceOf[_to] + _amount >= balanceOf[_to]);
-    activateAccount(_caller);
-    activateAccount(_to);
-    balanceOf[_caller] -= _amount;
-    if (_to == address(this)) treasuryBalance += _amount;
-    else {
-        uint256 fee = feeFor(_caller, _to, _amount);
-        balanceOf[_to] += _amount - fee;
-        treasuryBalance += fee;
-    }
-    Transfer(_caller, _to, _amount);
-    return true;
-  }
-
-  /**
-   * @notice Transfer `_amount` from `_from` to `_to`, invoked by `_caller`.
-   *
-   * @param _caller Invoker of the call (owner of the allowance)
-   * @param _from Origin address
-   * @param _to Address that will receive
-   * @param _amount Amount to be transferred.
-   * @return result of the method call
-   */
-  function transferFrom(address _caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {
-    assert(allowTransactions);
-    assert(!frozenAccount[_caller]);
-    assert(!frozenAccount[_from]);
-    assert(balanceOf[_from] >= _amount);
-    assert(balanceOf[_to] + _amount >= balanceOf[_to]);
-    assert(_amount <= allowance[_from][_caller]);
-    balanceOf[_from] -= _amount;
-    uint256 fee = feeFor(_from, _to, _amount);
-    balanceOf[_to] += _amount - fee;
-    treasuryBalance += fee;
-    allowance[_from][_caller] -= _amount;
-    activateAccount(_from);
-    activateAccount(_to);
-    activateAccount(_caller);
-    Transfer(_from, _to, _amount);
-    return true;
-  }
-
-  /**
-   * @notice Approve Approves spender `_spender` to transfer `_amount` from `_caller`
-   *
-   * @param _caller Address that grants the allowance
-   * @param _spender Address that receives the cheque
-   * @param _amount Amount on the cheque
-   * @param _extraData Consequential contract to be executed by spender in same transcation.
-   * @return result of the method call
-   */
-  function approveAndCall(address _caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {
-    assert(allowTransactions);
-    assert(!frozenAccount[_caller]);
-    allowance[_caller][_spender] = _amount;
-    activateAccount(_caller);
-    activateAccount(_spender);
-    activateAllowanceRecord(_caller, _spender);
-    TokenRecipient spender = TokenRecipient(_spender);
-    assert(Relay(assetAddress).relayReceiveApproval(_caller, _spender, _amount, _extraData));
-    Approval(_caller, _spender, _amount);
-    return true;
-  }
-
-  /**
-   * @notice Approve Approves spender `_spender` to transfer `_amount` from `_caller`
-   *
-   * @param _caller Address that grants the allowance
-   * @param _spender Address that receives the cheque
-   * @param _amount Amount on the cheque
-   * @return result of the method call
-   */
-  function approve(address _caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {
-    assert(allowTransactions);
-    assert(!frozenAccount[_caller]);
-    allowance[_caller][_spender] = _amount;
-    activateAccount(_caller);
-    activateAccount(_spender);
-    activateAllowanceRecord(_caller, _spender);
-    Approval(_caller, _spender, _amount);
-    return true;
-  }
-
-  /* ---------------  multisig admin methods  --------------*/
-
-
-  /**
-   * @notice Mints `mintedAmount` new tokens to the hotwallet `hotWalletAddress`.
-   *
-   * @param mintedAmount Amount of new tokens to be minted.
-   */
-  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {
-    activateAccount(hotWalletAddress);
-    balanceOf[hotWalletAddress] += mintedAmount;
-    totalSupply += mintedAmount;
-  }
-
-  /**
-   * @notice Destroys `destroyAmount` new tokens from the hotwallet `hotWalletAddress`
-   *
-   * @param destroyAmount Amount of new tokens to be minted.
-   */
-  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {
-    assert(balanceOf[hotWalletAddress] >= destroyAmount);
-    activateAccount(hotWalletAddress);
-    balanceOf[hotWalletAddress] -= destroyAmount;
-    totalSupply -= destroyAmount;
-  }
-
-  /**
-   * @notice Transfers `amount` from the treasury to `to`
-   *
-   * @param to Address to transfer to
-   * @param amount Amount to transfer from treasury
-   */
-  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {
-    assert(treasuryBalance >= amount);
-    treasuryBalance -= amount;
-    balanceOf[to] += amount;
-    activateAccount(to);
-  }
-
-  /* ---------------  multisig emergency methods --------------*/
-
-  /**
-   * @notice Sets allow transactions to `allow`
-   *
-   * @param allow Allow or disallow transactions
-   */
-  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {
-    if (allow == allowTransactions) throw;
-    allowTransactions = allow;
-  }
-
-  /**
-   * @notice Destructs the contract and sends remaining `this.balance` Ether to `beneficiary`
-   *
-   * @param beneficiary Beneficiary of remaining Ether on contract
-   */
-  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {
-    selfdestruct(beneficiary);
-  }
-
-  /**
-   * @notice Sets frozen to `freeze` for account `target`
-   *
-   * @param addr Address to be frozen/unfrozen
-   * @param freeze Freeze/unfreeze account
-   */
-  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {
-    frozenAccount[addr] = freeze;
-    activateAccount(addr);
-  }
-
-  /**
-   * @notice Seizes `seizeAmount` of tokens from `address` and transfers it to hotwallet
-   *
-   * @param addr Adress to seize tokens from
-   * @param amount Amount of tokens to seize
-   */
-  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {
-    assert(balanceOf[addr] >= amount);
-    assert(frozenAccount[addr]);
-    activateAccount(addr);
-    balanceOf[addr] -= amount;
-    balanceOf[hotWalletAddress] += amount;
-  }
-
-  /* ---------------  overseer methods for emergency --------------*/
-
-  /**
-   * @notice Shuts down all transaction and approval options on the asset contract
-   */
-  function shutdownTransactions() onlyOverseer {
-    allowTransactions = false;
-    TransactionsShutDown(msg.sender);
-  }
-
-  /* ---------------  helper methods for siphoning --------------*/
-
-  function extractAccountAllowanceRecordLength(address addr) returns (uint256 len) {
-    return allowanceIndex[addr].length;
-  }
-
-  function extractAccountLength() returns (uint256 length) {
-    return accountIndex.length;
-  }
-
-
-  /* ---------------  private methods --------------*/
-
-  function activateAccount(address addr) internal {
-    if (!accountActive[addr]) {
-      accountActive[addr] = true;
-      accountIndex.push(addr);
-    }
-  }
-
-  function activateAllowanceRecord(address from, address to) internal {
-    if (!allowanceActive[from][to]) {
-      allowanceActive[from][to] = true;
-      allowanceIndex[from].push(to);
-    }
-  }
-  function feeFor(address a, address b, uint256 amount) returns (uint256 value) {
-    if (membershipAddress == address(0x0)) return 0;
-    return DVIP(membershipAddress).feeFor(a, b, amount);
-  }
-}
-
-
-/**
- * @title DCAssetFacade, Facade for the underlying back-end dcasset token contract. Allow to be updated later.
- *
- * @author P.S.D. Reitsma, peter@decentralizedcapital.com
+ * @author Raymond Pulver IV
  *
  */
-contract DCAsset is TokenBase, StateTransferrable, TrustClient, Relay {
+contract DVIP is TokenBase, StateTransferrable, TrustClient, Relay {
 
    address public backendContract;
 
@@ -1224,28 +751,28 @@
     *
     *
     */
-   function DCAsset(address _backendContract) {
+   function DVIP(address _backendContract) {
      backendContract = _backendContract;
    }
 
    function standard() constant returns (bytes32 std) {
-     return DCAssetBackend(backendContract).standard();
+     return DVIPBackend(backendContract).standard();
    }
 
    function name() constant returns (bytes32 nm) {
-     return DCAssetBackend(backendContract).name();
+     return DVIPBackend(backendContract).name();
    }
 
    function symbol() constant returns (bytes32 sym) {
-     return DCAssetBackend(backendContract).symbol();
+     return DVIPBackend(backendContract).symbol();
    }
 
    function decimals() constant returns (uint8 precision) {
-     return DCAssetBackend(backendContract).decimals();
+     return DVIPBackend(backendContract).decimals();
    }
   
    function allowance(address from, address to) constant returns (uint256 res) {
-     return DCAssetBackend(backendContract).allowance(from, to);
+     return DVIPBackend(backendContract).allowance(from, to);
    }
 
 
@@ -1260,6 +787,9 @@
    function setBackend(address _backendContract) multisig(sha3(msg.data)) {
      backendContract = _backendContract;
    }
+   function setBackendOwner(address _backendContract) onlyOwnerUnlocked {
+     backendContract = _backendContract;
+   }
 
    /* ---------------  main token methods  --------------*/
 
@@ -1269,7 +799,7 @@
     * @param _address The address of the balance.
     */
    function balanceOf(address _address) constant returns (uint256 balance) {
-      return DCAssetBackend(backendContract).balanceOf(_address);
+      return DVIPBackend(backendContract).balanceOf(_address);
    }
 
    /**
@@ -1277,7 +807,7 @@
     *
     */
    function totalSupply() constant returns (uint256 balance) {
-      return DCAssetBackend(backendContract).totalSupply();
+      return DVIPBackend(backendContract).totalSupply();
    }
 
   /**
@@ -1287,7 +817,7 @@
    * @param _amount Amount to be transferred.
    */
    function transfer(address _to, uint256 _amount) returns (bool success)  {
-      if (!DCAssetBackend(backendContract).transfer(msg.sender, _to, _amount)) throw;
+      if (!DVIPBackend(backendContract).transfer(msg.sender, _to, _amount)) throw;
       Transfer(msg.sender, _to, _amount);
       return true;
    }
@@ -1301,7 +831,7 @@
    * @return result of the method call
    */
    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {
-      if (!DCAssetBackend(backendContract).approveAndCall(msg.sender, _spender, _amount, _extraData)) throw;
+      if (!DVIPBackend(backendContract).approveAndCall(msg.sender, _spender, _amount, _extraData)) throw;
       Approval(msg.sender, _spender, _amount);
       return true;
    }
@@ -1314,7 +844,7 @@
    * @return result of the method call
    */
    function approve(address _spender, uint256 _amount) returns (bool success) {
-      if (!DCAssetBackend(backendContract).approve(msg.sender, _spender, _amount)) throw;
+      if (!DVIPBackend(backendContract).approve(msg.sender, _spender, _amount)) throw;
       Approval(msg.sender, _spender, _amount);
       return true;
    }
@@ -1328,7 +858,7 @@
    * @return result of the method call
    */
   function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {
-      if (!DCAssetBackend(backendContract).transferFrom(msg.sender, _from, _to, _amount)) throw;
+      if (!DVIPBackend(backendContract).transferFrom(msg.sender, _from, _to, _amount)) throw;
       Transfer(_from, _to, _amount);
       return true;
   }
@@ -1341,8 +871,8 @@
    * @param _amount Amount to be transferred.
    * @return height of the fee
    */
-  function feeFor(address _from, address _to, uint256 _amount) returns (uint256 amount) {
-      return DCAssetBackend(backendContract).feeFor(_from, _to, _amount);
+  function feeFor(address _from, address _to, uint256 _amount) constant returns (uint256 amount) {
+      return DVIPBackend(backendContract).feeFor(_from, _to, _amount);
   }
 
   /* ---------------  to be called by backend  --------------*/
