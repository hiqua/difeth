--- 
+++ 
@@ -10,7 +10,19 @@
 // directly as the token does not implement the ERC20
 // transferFrom(...), approve(...) and allowance(...) methods
 //
-// Enjoy. (c) JonnyLatte & BokkyPooBah 2016. The MIT licence.
+// History:
+//   Jan 25 2017 - BPB Added makerTransferAsset(...) and
+//                     makerTransferEther(...)
+//   Feb 05 2017 - BPB Bug fix in the change calculation for the Unicorn
+//                     token with natural number 1
+//   Feb 08 2017 - BPB/JL Renamed etherValueOfTokensToSell to
+//                     amountOfTokensToSell in takerSellAsset(...) to
+//                     better describe the parameter
+//                     Added check in createTradeContract(...) to prevent
+//                     GNTs from being used with this contract. The asset
+//                     token will need to have an allowance(...) function.
+//
+// Enjoy. (c) JonnyLatte & BokkyPooBah 2017. The MIT licence.
 // ------------------------------------------------------------------------
 
 // https://github.com/ethereum/EIPs/issues/20
@@ -71,7 +83,7 @@
     event MakerTransferredEther(address toTokenTrader, uint256 ethers);
     event TakerBoughtAsset(address indexed buyer, uint256 ethersSent,
         uint256 ethersReturned, uint256 tokensBought);
-    event TakerSoldAsset(address indexed seller, uint256 etherValueOfTokensToSell,
+    event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell,
         uint256 tokensSold, uint256 etherValueOfTokensSold);
 
     // Constructor - only to be called by the TokenTraderFactory contract
@@ -82,7 +94,7 @@
         uint256 _units,
         bool    _buysTokens,
         bool    _sellsTokens
-    ) internal {
+    ) {
         asset       = _asset;
         buyPrice    = _buyPrice;
         sellPrice   = _sellPrice;
@@ -255,13 +267,15 @@
             // Note that units has already been validated as > 0
             uint can_sell = ERC20(asset).balanceOf(address(this)) / units;
             uint256 change = 0;
-            if (order > can_sell) {
-                change = msg.value - (can_sell * sellPrice);
+            if (msg.value > (can_sell * sellPrice)) {
+                change  = msg.value - (can_sell * sellPrice);
                 order = can_sell;
+            }
+            if (change > 0) {
                 if (!msg.sender.send(change)) throw;
             }
             if (order > 0) {
-                if(!ERC20(asset).transfer(msg.sender, order * units)) throw;
+                if (!ERC20(asset).transfer(msg.sender, order * units)) throw;
             }
             TakerBoughtAsset(msg.sender, msg.value, change, order * units);
         }
@@ -278,31 +292,31 @@
     //                        by the taker
     //
     // The TakerSoldAsset() event is logged with the following parameters
-    //   seller                    is the seller's address
-    //   etherValueOfTokensToSell  is the ether value of the asset tokens being
-    //                             sold by the taker
-    //   tokensSold                is the number of the asset tokens sold
-    //   etherValueOfTokensSold    is the ether value of the asset tokens sold
+    //   seller                  is the seller's address
+    //   amountOfTokensToSell    is the amount of the asset tokens being
+    //                           sold by the taker
+    //   tokensSold              is the number of the asset tokens sold
+    //   etherValueOfTokensSold  is the ether value of the asset tokens sold
     //
     // This method was called sell() in the old version
     //
-    function takerSellAsset(uint256 etherValueOfTokensToSell) {
+    function takerSellAsset(uint256 amountOfTokensToSell) {
         if (buysTokens || msg.sender == owner) {
             // Maximum number of token the contract can buy
             // Note that buyPrice has already been validated as > 0
             uint256 can_buy = this.balance / buyPrice;
             // Token lots available
             // Note that units has already been validated as > 0
-            uint256 order = etherValueOfTokensToSell / units;
+            uint256 order = amountOfTokensToSell / units;
             // Adjust order for funds available
             if (order > can_buy) order = can_buy;
             if (order > 0) {
                 // Extract user tokens
-                if(!ERC20(asset).transferFrom(msg.sender, address(this), order * units)) throw;
+                if (!ERC20(asset).transferFrom(msg.sender, address(this), order * units)) throw;
                 // Pay user
-                if(!msg.sender.send(order * buyPrice)) throw;
+                if (!msg.sender.send(order * buyPrice)) throw;
             }
-            TakerSoldAsset(msg.sender, etherValueOfTokensToSell, order * units, order * buyPrice);
+            TakerSoldAsset(msg.sender, amountOfTokensToSell, order * units, order * buyPrice);
         }
     }
 
@@ -401,12 +415,18 @@
     ) returns (address trader) {
         // Cannot have invalid asset
         if (asset == 0x0) throw;
+        // Check for ERC20 allowance function
+        // This will throw an error if the allowance function
+        // is undefined to prevent GNTs from being used
+        // with this factory
+        uint256 allowance = ERC20(asset).allowance(msg.sender, this);
         // Cannot set zero or negative price
         if (buyPrice <= 0 || sellPrice <= 0) throw;
         // Must make profit on spread
         if (buyPrice >= sellPrice) throw;
         // Cannot buy or sell zero or negative units
         if (units <= 0) throw;
+
         trader = new TokenTrader(
             asset,
             buyPrice,
