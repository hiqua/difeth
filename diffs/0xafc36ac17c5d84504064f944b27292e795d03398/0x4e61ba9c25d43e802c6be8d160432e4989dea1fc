--- 
+++ 
@@ -10,18 +10,19 @@
   OR until cut-off time defined below is exceeded and as a result ETH
   refunds/withdrawals become enabled.
 
+  The buyer's ETH will ONLY be released to the seller AFTER the buyer
+  manually withdraws their tokens by sending this contract a transaction
+  with 0 ETH.
+
   In other words, the seller must fulfill the IOU token purchases any time
   before the cut-off time defined below, otherwise the buyer gains the
   ability to withdraw their ETH.
 
-  The buyer's ETH will ONLY be released to the seller AFTER the adequate
-  amount of tokens have been deposited for ALL purchases.
-
   Estimated Time of Distribution: 3-5 weeks from ICO according to TenX
   Cut-off Time: ~ August 9, 2017
 
-  Greetz: blast
-  foobarbizarre@gmail.com (Please report any findings or suggestions for a 1 ETH bounty!)
+  Greetz: blast, cintix
+  Bounty: foobarbizarre@gmail.com (Please report any findings or suggestions!)
 
   Thank you
 */
@@ -39,82 +40,44 @@
   mapping (address => uint256) public eth_sent;
 
   // Total IOUs available to sell
-  uint256 public total_iou_available = 40000000000000000000000;
+  uint256 public total_iou_available = 52500000000000000000000;
 
   // Total IOUs purchased by all buyers
   uint256 public total_iou_purchased;
-
-  // Total IOU withdrawn by all buyers (keep track to protect buyers)
-  uint256 public total_iou_withdrawn;
-
-  // IOU per ETH (price)
-  uint256 public price_per_eth = 100;
 
   //  PAY token contract address (IOU offering)
   ERC20 public token = ERC20(0xB97048628DB6B661D4C2aA833e95Dbe1A905B280);
 
   // The seller's address (to receive ETH upon distribution, and for authing safeties)
-  address seller = 0x496529c12e229e9787D37E5EFA2E48B651e755B0;
+  address seller = 0xB00Ae1e677B27Eee9955d632FF07a8590210B366;
 
   // Halt further purchase ability just in case
   bool public halt_purchases;
 
-  modifier pwner() { if(msg.sender != seller) throw; _; }
-
   /*
-    Safety to withdraw unbought tokens back to seller. Ensures the amount
-    that buyers still need to withdraw remains available
+    Safety to withdraw all tokens back to seller in the event any get stranded.
+    Does not leave buyers susceptible. If anything, not enough tokens in the contract
+    will enable them to withdraw their ETH so long as the specified block.number has been mined
   */
-  function withdrawTokens() pwner {
-    token.transfer(seller, token.balanceOf(address(this)) - (total_iou_purchased - total_iou_withdrawn));
+  function withdrawTokens() {
+    if(msg.sender != seller) throw;
+    token.transfer(seller, token.balanceOf(address(this)));
   }
 
   /*
     Safety to prevent anymore purchases/sales from occurring in the event of
-    unforeseen issue. Buyer withdrawals still remain enabled.
+    unforeseen issue, or if seller wishes to limit this particular sale price
+    and start a new contract with a new price. The contract will of course
+    allow withdrawals to occur still.
   */
-  function haltPurchases() pwner {
+  function haltPurchases() {
+    if(msg.sender != seller) throw;
     halt_purchases = true;
   }
 
-  function resumePurchases() pwner {
+  function resumePurchases() {
+    if(msg.sender != seller) throw;
     halt_purchases = false;
-  }
-
-  /*
-    Update available IOU to purchase
-  */
-  function updateAvailability(uint256 _iou_amount) pwner {
-    if(_iou_amount < total_iou_purchased) throw;
-
-    total_iou_available = _iou_amount;
-  }
-
-  /*
-    Update IOU price
-  */
-  function updatePrice(uint256 _price) pwner {
-    price_per_eth = _price;
-  }
-
-  /*
-    Release buyer's ETH to seller ONLY if amount of contract's tokens balance
-    is >= to the amount that still needs to be withdrawn. Protects buyer.
-
-    The seller must call this function manually after depositing the adequate
-    amount of tokens for all buyers to collect
-
-    This effectively ends the sale, but withdrawals remain open
-  */
-  function paySeller() pwner {
-    // not enough tokens in balance to release ETH, protect buyer and abort
-    if(token.balanceOf(address(this)) < (total_iou_purchased - total_iou_withdrawn)) throw;
-
-    // Halt further purchases to prevent accidental over-selling
-    halt_purchases = true;
-
-    // Release buyer's ETH to the seller
-    seller.transfer(this.balance);
   }
 
   function withdraw() payable {
@@ -144,7 +107,7 @@
       // If the user doesn't have any ETH or tokens to withdraw, get out ASAP
       if(eth_to_refund == 0 || iou_purchased[msg.sender] == 0) throw;
 
-      // Adjust total purchased so others can buy, and so numbers align with total_iou_withdrawn
+      // Adjust total purchased so others can buy
       total_iou_purchased -= iou_purchased[msg.sender];
 
       // Clear record of buyer's ETH and IOU balance before refunding
@@ -157,31 +120,32 @@
 
     /*
       Check if there is an adequate amount of tokens in the contract yet
-      and allow the buyer to withdraw tokens
+      and allow the buyer to withdraw tokens and release ETH to the seller if so
     */
     if(token.balanceOf(address(this)) == 0 || iou_purchased[msg.sender] > token.balanceOf(address(this))) throw;
 
     uint256 iou_to_withdraw = iou_purchased[msg.sender];
+    uint256 eth_to_release = eth_sent[msg.sender];
 
-    // If the user doesn't have any IOUs to withdraw, get out ASAP
-    if(iou_to_withdraw == 0) throw;
+    // If the user doesn't have any IOUs or ETH to withdraw/release, get out ASAP
+    if(iou_to_withdraw == 0 || eth_to_release == 0) throw;
 
     // Clear record of buyer's IOU and ETH balance before transferring out
     iou_purchased[msg.sender] = 0;
     eth_sent[msg.sender] = 0;
 
-    total_iou_withdrawn += iou_to_withdraw;
-
     // Distribute tokens to the buyer
     token.transfer(msg.sender, iou_to_withdraw);
+
+    // Release buyer's ETH to the seller
+    seller.transfer(eth_to_release);
   }
 
   function purchase() payable {
     if(halt_purchases) throw;
-    if(msg.value == 0) throw;
 
     // Determine amount of tokens user wants to/can buy
-    uint256 iou_to_purchase = price_per_eth * msg.value;
+    uint256 iou_to_purchase = 160 * msg.value; // price is 160 per ETH
 
     // Check if we have enough IOUs left to sell
     if((total_iou_purchased + iou_to_purchase) > total_iou_available) throw;
