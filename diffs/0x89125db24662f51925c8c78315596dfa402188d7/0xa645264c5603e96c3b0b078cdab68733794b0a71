--- 
+++ 
@@ -86,11 +86,6 @@
   /* approve() allowances */
   mapping (address => mapping (address => uint)) allowed;
 
-  /* Interface declaration */
-  function isToken() public constant returns (bool weAre) {
-    return true;
-  }
-
   /**
    *
    * Fix for the ERC20 short address attack
@@ -98,7 +93,7 @@
    * http://vessenes.com/the-erc20-short-address-attack-explained/
    */
   modifier onlyPayloadSize(uint size) {
-     if(msg.data.length < size + 4) {
+     if(msg.data.length != size + 4) {
        throw;
      }
      _;
@@ -114,6 +109,9 @@
   function transferFrom(address _from, address _to, uint _value) returns (bool success) {
     uint _allowance = allowed[_from][msg.sender];
 
+    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met
+    // if (_value > _allowance) throw;
+
     balances[_to] = safeAdd(balances[_to], _value);
     balances[_from] = safeSub(balances[_from], _value);
     allowed[_from][msg.sender] = safeSub(_allowance, _value);
@@ -142,6 +140,41 @@
     return allowed[_owner][_spender];
   }
 
+  /**
+   * Atomic increment of approved spending
+   *
+   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
+   *
+   */
+  function addApproval(address _spender, uint _addedValue)
+  onlyPayloadSize(2 * 32)
+  returns (bool success) {
+      uint oldValue = allowed[msg.sender][_spender];
+      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);
+      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
+      return true;
+  }
+
+  /**
+   * Atomic decrement of approved spending.
+   *
+   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
+   */
+  function subApproval(address _spender, uint _subtractedValue)
+  onlyPayloadSize(2 * 32)
+  returns (bool success) {
+
+      uint oldVal = allowed[msg.sender][_spender];
+
+      if (_subtractedValue > oldVal) {
+          allowed[msg.sender][_spender] = 0;
+      } else {
+          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);
+      }
+      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
+      return true;
+  }
+
 }
 
 
@@ -440,7 +473,7 @@
 
   function plus(uint a, uint b) returns (uint) {
     uint c = a + b;
-    assert(c>=a);
+    assert(c>=a && c>=b);
     return c;
   }
 
@@ -467,20 +500,20 @@
   /** List of agents that are allowed to create new tokens */
   mapping (address => bool) public mintAgents;
 
-  event MintingAgentChanged(address addr, bool state  );
-
   /**
    * Create new tokens and allocate them to an address..
    *
    * Only callably by a crowdsale contract (mint agent).
    */
   function mint(address receiver, uint amount) onlyMintAgent canMint public {
+
+    if(amount == 0) {
+      throw;
+    }
+
     totalSupply = totalSupply.plus(amount);
     balances[receiver] = balances[receiver].plus(amount);
-
-    // This will make the mint transaction apper in EtherScan.io
-    // We can remove this after there is a standardized minting event
-    Transfer(0, receiver, amount);
+    Minted(receiver, amount);
   }
 
   /**
@@ -488,7 +521,6 @@
    */
   function setMintAgent(address addr, bool state) onlyOwner canMint public {
     mintAgents[addr] = state;
-    MintingAgentChanged(addr, state);
   }
 
   modifier onlyMintAgent() {
@@ -508,6 +540,7 @@
 
 
 
+
 /**
  * A crowdsaled token.
  *
@@ -521,7 +554,6 @@
  */
 contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {
 
-  /** Name and symbol were updated. */
   event UpdatedTokenInformation(string newName, string newSymbol);
 
   string public name;
@@ -534,14 +566,8 @@
    * Construct the token.
    *
    * This token must be created through a team multisig wallet, so that it is owned by that wallet.
-   *
-   * @param _name Token name
-   * @param _symbol Token symbol - should be all caps
-   * @param _initialSupply How many tokens we start with
-   * @param _decimals Number of decimal places
-   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.
-   */
-  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)
+   */
+  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals)
     UpgradeableToken(msg.sender) {
 
     // Create any address, can be transferred
@@ -558,18 +584,6 @@
 
     // Create initially all balance on the team multisig
     balances[owner] = totalSupply;
-
-    if(totalSupply > 0) {
-      Minted(owner, totalSupply);
-    }
-
-    // No more new supply allowed after the token creation
-    if(!_mintable) {
-      mintingFinished = true;
-      if(totalSupply == 0) {
-        throw; // Cannot create a token without supply and no minting
-      }
-    }
   }
 
   /**
@@ -584,17 +598,11 @@
    * Allow upgrade agent functionality kick in only if the crowdsale was success.
    */
   function canUpgrade() public constant returns(bool) {
-    return released && super.canUpgrade();
-  }
-
-  /**
-   * Owner can update token information here.
-   *
-   * It is often useful to conceal the actual token association, until
-   * the token operations, like central issuance or reissuance have been completed.
-   *
-   * This function allows the token owner to rename the token after the operations
-   * have been completed and then point the audience to use the token contract.
+    return released;
+  }
+
+  /**
+   * Owner can update token information here
    */
   function setTokenInformation(string _name, string _symbol) onlyOwner {
     name = _name;
