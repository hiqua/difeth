--- 
+++ 
@@ -1,273 +1,216 @@
-contract IProxyManagement { 
-    function isProxyLegit(address _address) returns (bool){}
-    function raiseTransferEvent(address _from, address _to, uint _ammount){}
-    function raiseApprovalEvent(address _sender,address _spender,uint _value){}
-    function dedicatedProxyAddress() constant returns (address contractAddress){}
-}
-
-contract ITokenRecipient { 
-	function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); 
-}
-
-contract IFundManagement {
-	function fundsCombinedValue() constant returns (uint value){}
-    function getFundAlterations() returns (uint alterations){}
-}
-
-contract IERC20Token {
-
-    function totalSupply() constant returns (uint256 supply);
-    function balanceOf(address _owner) constant returns (uint256 balance);
+pragma solidity ^0.4.6;
+
+contract Token {
+    bytes32 public standard;
+    bytes32 public name;
+    bytes32 public symbol;
+    uint256 public totalSupply;
+    uint8 public decimals;
+    bool public allowTransactions;
+    mapping (address => uint256) public balanceOf;
+    mapping (address => mapping (address => uint256)) public allowance;
     function transfer(address _to, uint256 _value) returns (bool success);
+    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);
+    function approve(address _spender, uint256 _value) returns (bool success);
     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
-    function approve(address _spender, uint256 _value) returns (bool success);
-    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
-
-    event Transfer(address indexed _from, address indexed _to, uint256 _value);
-    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
-}
-
-contract MacroTokenContract{
-    
-    address public dev;
-    address public curator;
-    address public mintingContractAddress;
-    address public destructionContractAddress;
-    uint256 public totalSupply = 0;
-    bool public lockdown = false;
-
-    string public standard = 'Macro token';
-    string public name = 'Macro';
-    string public symbol = 'MCR';
-    uint8 public decimals = 8;
-
-    mapping (address => uint256) balances;
-    mapping (address => mapping (address => uint256)) allowed;
-    IProxyManagement proxyManagementContract;
-    IFundManagement fundManagementContract;
-
-    uint public weiForMcr;
-    uint public mcrAmmountForGas;
-
-    event Transfer(address indexed _from, address indexed _to, uint256 _value);
-    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
-    event Mint(address _destination, uint _amount);
-    event Destroy(address _destination, uint _amount);
-    event McrForGasFailed(address _failedAddress, uint _ammount);
-
-    function MacroTokenContract() { 
-        dev = msg.sender;
+}
+
+
+contract DVIP {
+  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value);
+}
+
+contract Assertive {
+  function assert(bool assertion) {
+    if (!assertion) throw;
+  }
+}
+
+contract Owned is Assertive {
+  address internal owner;
+  event SetOwner(address indexed previousOwner, address indexed newOwner);
+  function Owned () {
+    owner = msg.sender;
+  }
+  modifier onlyOwner {
+    assert(msg.sender == owner);
+    _;
+  }
+  function setOwner(address newOwner) onlyOwner {
+    SetOwner(owner, newOwner);
+    owner = newOwner;
+  }
+  function getOwner() returns (address out) {
+    return owner;
+  }
+}
+
+contract Math is Assertive {
+  function safeMul(uint a, uint b) internal returns (uint) {
+    uint c = a * b;
+    assert(a == 0 || c / a == b);
+    return c;
+  }
+
+  function safeSub(uint a, uint b) internal returns (uint) {
+    assert(b <= a);
+    return a - b;
+  }
+
+  function safeAdd(uint a, uint b) internal returns (uint) {
+    uint c = a + b;
+    assert(c>=a && c>=b);
+    return c;
+  }
+}
+
+contract ExchangeWhitelist is Math, Owned {
+
+  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances
+
+  struct Account {
+    bool authorized;
+    uint256 tier;
+    uint256 resetWithdrawal;
+    uint256 withdrawn;
+  }
+
+  mapping (address => Account) public accounts;
+  mapping (address => bool) public whitelistAdmins;
+  mapping (address => bool) public admins;
+  //ether balances are held in the token=0 account
+  mapping (bytes32 => uint256) public orderFills;
+  address public feeAccount;
+  address public dvipAddress;
+  address public feeMakeExporter;
+  address public feeTakeExporter;
+  event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);
+  event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);
+  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give, bytes32 hash);
+  event Deposit(address token, address user, uint256 amount, uint256 balance);
+  event Withdraw(address token, address user, uint256 amount, uint256 balance);
+
+  function ExchangeWhitelist(address feeAccount_, address dvipAddress_) {
+    feeAccount = feeAccount_;
+    dvipAddress = dvipAddress_;
+    feeMakeExporter = 0x00000000000000000000000000000000000000f7;
+    feeTakeExporter = 0x00000000000000000000000000000000000000f8;
+  }
+
+  function setFeeAccount(address feeAccount_) onlyOwner {
+    feeAccount = feeAccount_;
+  }
+
+  function setDVIP(address dvipAddress_) onlyOwner {
+    dvipAddress = dvipAddress_;
+  }
+
+  function setAdmin(address admin, bool isAdmin) onlyOwner {
+    admins[admin] = isAdmin;
+  }
+
+  function setWhitelister(address whitelister, bool isWhitelister) onlyOwner {
+    whitelistAdmins[whitelister] = isWhitelister;
+  }
+
+  modifier onlyWhitelister {
+    if (!whitelistAdmins[msg.sender]) throw;
+    _;
+  }
+
+  modifier onlyAdmin {
+    if (msg.sender != owner && !admins[msg.sender]) throw;
+    _;
+  }
+  function setWhitelisted(address target, bool isWhitelisted) onlyWhitelister {
+    accounts[target].authorized = isWhitelisted;
+  }
+  modifier onlyWhitelisted {
+    if (!accounts[msg.sender].authorized) throw;
+    _;
+  }
+
+  function() {
+    throw;
+  }
+
+  function deposit(address token, uint256 amount) payable {
+    if (token == address(0)) {
+      tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);
+    } else {
+      if (msg.value != 0) throw;
+      tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);
+      if (!Token(token).transferFrom(msg.sender, this, amount)) throw;
     }
-    
-    function balanceOf(address _owner) constant returns (uint256 balance) {
-        return balances[_owner];
+    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);
+  }
+
+  function withdraw(address token, uint256 amount) {
+    if (tokens[token][msg.sender] < amount) throw;
+    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);
+    if (token == address(0)) {
+      if (!msg.sender.send(amount)) throw;
+    } else {
+      if (!Token(token).transfer(msg.sender, amount)) throw;
     }
-
-    function transfer(address _to, uint256 _value) returns (bool success){
-        if(balances[msg.sender] < _value) throw;
-        if(balances[_to] + _value <= balances[_to]) throw;
-        if(lockdown) throw;
-
-        balances[msg.sender] -= _value;
-        balances[_to] += _value;
-        createTransferEvent(true, msg.sender, _to, _value);              
-        return true;
-    }
-
-    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
-        if(balances[_from] < _value) throw;
-        if(balances[_to] + _value <= balances[_to]) throw;
-        if(_value > allowed[_from][msg.sender]) throw;
-        if(lockdown) throw;
-
-        balances[_from] -= _value;
-        balances[_to] += _value;
-        createTransferEvent(true, _from, _to, _value);
-        allowed[_from][msg.sender] -= _value;
-        return true;
-    }
-
-    function approve(address _spender, uint256 _value) returns (bool success) {
-        if(lockdown) throw;
-        
-        allowed[msg.sender][_spender] = _value;
-        createApprovalEvent(true, msg.sender, _spender, _value);
-        return true;
-    }
-
-    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
-      return allowed[_owner][_spender];
-    }
-
-    function transferViaProxy(address _source, address _to, uint256 _amount) returns (bool success){
-        if (!proxyManagementContract.isProxyLegit(msg.sender)) throw;
-        if (balances[_source] < _amount) throw;
-        if (balances[_to] + _amount <= balances[_to]) throw;
-        if (lockdown) throw;
-
-        balances[_source] -= _amount;
-        balances[_to] += _amount;
-
-        if (msg.sender == proxyManagementContract.dedicatedProxyAddress()){
-            createTransferEvent(false, _source, _to, _amount); 
-        }else{
-            createTransferEvent(true, _source, _to, _amount); 
-        }
-        return true;
-    }
-    
-    function transferFromViaProxy(address _source, address _from, address _to, uint256 _amount) returns (bool success) {
-        if (!proxyManagementContract.isProxyLegit(msg.sender)) throw;
-        if (balances[_from] < _amount) throw;
-        if (balances[_to] + _amount <= balances[_to]) throw;
-        if (lockdown) throw;
-        if (_amount > allowed[_from][_source]) throw;
-
-        balances[_from] -= _amount;
-        balances[_to] += _amount;
-        allowed[_from][_source] -= _amount;
-
-        if (msg.sender == proxyManagementContract.dedicatedProxyAddress()){
-            createTransferEvent(false, _source, _to, _amount); 
-        }else{
-            createTransferEvent(true, _source, _to, _amount); 
-        }
-        return true;
-    }
-    
-    function approveViaProxy(address _source, address _spender, uint256 _value) returns (bool success) {
-        if (!proxyManagementContract.isProxyLegit(msg.sender)) throw;
-        if(lockdown) throw;
-        
-        allowed[_source][_spender] = _value;
-        if (msg.sender == proxyManagementContract.dedicatedProxyAddress()){
-            createApprovalEvent(false, _source, _spender, _value);
-        }else{
-            createApprovalEvent(true, _source, _spender, _value);
-        }
-        return true;
-    }
-
-    function mint(address _destination, uint _amount) returns (bool success){
-        if (msg.sender != mintingContractAddress) throw;
-        if(balances[_destination] + _amount < balances[_destination]) throw;
-        if(totalSupply + _amount < totalSupply) throw;
-
-        totalSupply += _amount;
-        balances[_destination] += _amount;
-        Mint(_destination, _amount);
-        createTransferEvent(true, 0x0, _destination, _amount);
-        return true;
-    }
-
-    function destroy(address _destination, uint _amount) returns (bool success) {
-        if (msg.sender != destructionContractAddress) throw;
-        if (balances[_destination] < _amount) throw;
-
-        totalSupply -= _amount;
-        balances[_destination] -= _amount;
-        Destroy(_destination, _amount);
-        createTransferEvent(true, _destination, 0x0, _amount);
-        return true;
-    }
-
-    function setTokenCurator(address _curatorAddress){
-        if( msg.sender != dev) throw;
-        curator = _curatorAddress;
-    }
-    
-    function setMintingContractAddress(address _contractAddress){ 
-        if (msg.sender != curator) throw;
-        mintingContractAddress = _contractAddress;
-    }
-
-    function setDescrutionContractAddress(address _contractAddress){ 
-        if (msg.sender != curator) throw;
-        destructionContractAddress = _contractAddress;
-    }
-
-    function setProxyManagementContract(address _contractAddress){
-        if (msg.sender != curator) throw;
-        proxyManagementContract = IProxyManagement(_contractAddress);
-    }
-
-    function setFundManagementContract(address _contractAddress){
-        if (msg.sender != curator) throw;
-        fundManagementContract = IFundManagement(_contractAddress);
-    }
-
-    function emergencyLock() {
-        if (msg.sender != curator && msg.sender != dev) throw;
-        
-        lockdown = !lockdown;
-    }
-
-    function killContract(){
-        if (msg.sender != dev) throw;
-        selfdestruct(dev);
-    }
-
-    function setWeiForMcr(uint _value){
-        if (msg.sender != curator) throw;
-        weiForMcr = _value;
-    }
-    
-    function setMcrAmountForGas(uint _value){
-        if (msg.sender != curator) throw;
-        mcrAmmountForGas = _value;
-    }
-
-    function getGasForMcr(){
-        if (balances[msg.sender] < mcrAmmountForGas) throw;
-        if (balances[curator] > balances[curator] + mcrAmmountForGas) throw;
-        if (this.balance < weiForMcr * mcrAmmountForGas) throw;
-
-        balances[msg.sender] -= mcrAmmountForGas;
-        balances[curator] += mcrAmmountForGas;
-        createTransferEvent(true, msg.sender, curator, weiForMcr * mcrAmmountForGas);
-        if (!msg.sender.send(weiForMcr * mcrAmmountForGas)) {
-            McrForGasFailed(msg.sender, weiForMcr * mcrAmmountForGas);
-        }
-    }
-
-    function fundManagementAddress() constant returns (address fundManagementAddress){
-        return address(fundManagementContract);
-    }
-
-    function proxyManagementAddress() constant returns (address proxyManagementAddress){
-        return address(proxyManagementContract);
-    }
-
-    function fundsCombinedValue() constant returns (uint value){
-        return fundManagementContract.fundsCombinedValue();
-    }
-
-    function getGasForMcrData() constant returns (uint, uint){
-        return (weiForMcr, mcrAmmountForGas);
-    }
-
-    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
-        allowed[msg.sender][_spender] = _value;
-        ITokenRecipient spender = ITokenRecipient(_spender);
-        spender.receiveApproval(msg.sender, _value, this, _extraData);
-        return true;
-    }
-
-    function createTransferEvent(bool _relayEvent, address _from, address _to, uint256 _value) internal {
-        if (_relayEvent){
-            proxyManagementContract.raiseTransferEvent(_from, _to, _value);
-        }
-        Transfer(_from, _to, _value);
-    }
-
-    function createApprovalEvent(bool _relayEvent, address _sender, address _spender, uint _value) internal {
-        if (_relayEvent){
-            proxyManagementContract.raiseApprovalEvent(_sender, _spender, _value);
-        }
-        Approval(_sender, _spender, _value);
-    }
-    
-    function fillContract() payable{
-        if (msg.sender != curator) throw;
-    }
+    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);
+  }
+
+  function balanceOf(address token, address user) constant returns (uint256) {
+    return tokens[token][user];
+  }
+
+  uint256 internal feeTake;
+  uint256 internal feeMake;
+  uint256 internal feeTerm;
+  bytes32 internal tradeHash;
+
+  function trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s, uint256 amount) onlyWhitelisted {
+    //amount is in amountBuy terms
+    tradeHash = sha3(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user);
+    if (!(
+      ecrecover(sha3("\x19Ethereum Signed Message:\n32", tradeHash),v,r,s) == user &&
+      block.number <= expires &&
+      safeAdd(orderFills[tradeHash], amount) <= amountBuy &&
+      tokens[tokenBuy][msg.sender] >= amount &&
+      tokens[tokenSell][user] >= safeMul(amountSell, amount) / amountBuy
+    )) throw;
+    feeMake = DVIP(dvipAddress).feeFor(feeMakeExporter, msg.sender, 1 ether);
+    feeTake = DVIP(dvipAddress).feeFor(feeTakeExporter, user, 1 ether);
+    tokens[tokenBuy][msg.sender] = safeSub(tokens[tokenBuy][msg.sender], amount);
+    feeTerm = safeMul(amount, ((1 ether) - feeMake)) / (1 ether);
+    tokens[tokenBuy][user] = safeAdd(tokens[tokenBuy][user], feeTerm);
+    feeTerm = safeMul(amount, feeMake) / (1 ether);
+    tokens[tokenBuy][feeAccount] = safeAdd(tokens[tokenBuy][feeAccount], feeTerm);
+    feeTerm = safeMul(amountSell, amount) / amountBuy;
+    tokens[tokenSell][user] = safeSub(tokens[tokenSell][user], feeTerm);
+    feeTerm = safeMul(safeMul(((1 ether) - feeTake), amountSell), amount) / amountBuy / (1 ether);
+    tokens[tokenSell][msg.sender] = safeAdd(tokens[tokenSell][msg.sender], feeTerm);
+    feeTerm = safeMul(safeMul(feeTake, amountSell), amount) / amountBuy / (1 ether);
+    tokens[tokenSell][feeAccount] = safeAdd(tokens[tokenSell][feeAccount], feeTerm);
+    orderFills[tradeHash] = safeAdd(orderFills[tradeHash], amount);
+    Trade(tokenBuy, amount, tokenSell, amountSell * amount / amountBuy, user, msg.sender, tradeHash);
+  }
+
+  bytes32 internal testHash;
+  uint256 internal amountSelln;
+
+  function testTrade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s, uint256 amount, address sender) constant returns (uint8 code) {
+    testHash = sha3(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user);
+    if (tokens[tokenBuy][sender] < amount) return 1;
+    if (!accounts[sender].authorized) return 2; 
+    if (!accounts[user].authorized) return 3;
+    if (ecrecover(sha3("\x19Ethereum Signed Message:\n32", testHash), v, r, s) != user) return 4;
+    amountSelln = safeMul(amountSell, amount) / amountBuy;
+    if (tokens[tokenSell][user] < amountSelln) return 5;
+    if (block.number > expires) return 6;
+    if (safeAdd(orderFills[testHash], amount) > amountBuy) return 7;
+    return 0;
+  }
+  function cancelOrder(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, uint8 v, bytes32 r, bytes32 s, address user) {
+    bytes32 hash = sha3(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user);
+    if (ecrecover(sha3("\x19Ethereum Signed Message:\n32", hash),v,r,s) != msg.sender) throw;
+    orderFills[hash] = amountBuy;
+    Cancel(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, msg.sender, v, r, s);
+  }
 }