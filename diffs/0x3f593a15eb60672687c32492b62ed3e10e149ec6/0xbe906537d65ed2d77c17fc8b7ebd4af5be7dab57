--- 
+++ 
@@ -1,641 +1,604 @@
-contract Etherization {
+contract MyTokenShr {
+	
+    Company public myCompany;
+	bool active = false;
+	
+	modifier onlyActive {if(active) _ }
+    modifier onlyfromcompany {if(msg.sender == address(myCompany)) _ }
+	
+	function initContract(string _name, string _symbol, uint _firstTender, 
+						  uint _startPrice )  {
+		if(active) throw;
+		name = _name;
+		symbol =  _symbol;
+		myCompany = Company(msg.sender);
+		addTender(1,_firstTender, 0, _startPrice);
+		active = true;
+	}
+
+
+    // Tender Mechanism..
+	// Issue New Tokens only in tender
+	//
+  	struct Tender { uint id;
+                  uint maxstake;
+                  uint usedstake;
+                  address reservedFor;
+                  uint priceOfStake;
+  	}
+ 	Tender[] activeTenders;
+  
+  	function addTender(uint nid, uint nmaxstake, address nreservedFor,uint _priceOfStake) {
+
+		//ToDo: freigabe durch Board
     
-    // 1 eth starting price
-    uint public START_PRICE = 1000000000000000000;
-    // 0.8 eth city build price
-    uint public CITY_PRICE = 800000000000000000;
-    // 0.5 eth building build price
-    uint public BUILDING_PRICE = 500000000000000000;
-    // 0.2 eth unit build price
-    uint public UNIT_PRICE = 200000000000000000;
-    // 0.02 eth unit maintenance price
-    uint public MAINT_PRICE = 20000000000000000;
-    // 0.1 eth min withdraw amount to prevent spam
-    uint public MIN_WTH = 100000000000000000;
-    
-    // minimum time to wait between moves in seconds
-    uint public WAIT_TIME = 14400;
-    uint MAP_ROWS = 34;
-    uint MAP_COLS = 34;
-    
-    
-    struct City {
-        uint owner;
-        string name;
-        // 0 - quarry, 1 - farm, 2 - woodworks, 3 - metalworks, 4 -stables
-        bool[5] buildings;
-        // 1 - pikemen, 2 - swordsmen, 3 - horsemen
-        uint[10] units; //maximum num of units per city 10
-        uint[2] rowcol;
-        int previousID;
-        int nextID;
-    }
-    
-    struct Player {
-        // Player address
-        address etherAddress;
-        // Their name
-        string name;
-        // Their treasury balance
-        uint treasury;
-        // Their capitol
-        uint capitol;
-        // Number of cities the player has under control
-        uint numCities;
-        uint numUnits;
-        // When was their last move (based on block.timestamp)
-        uint lastTimestamp;
-    }
-    
-    Player player;
-    Player[] public players;
-    uint public numPlayers = 0;
-    
-    mapping(address => uint) playerIDs;
-    mapping(uint => uint) public playerMsgs;
-    
-    City city;
-    City[] public cities;
-    uint public numCities = 0;
-    
-    uint[] public quarryCities;
-    uint[] public farmCities;
-    uint[] public woodworksCities;
-    uint[] public metalworksCities;
-    uint[] public stablesCities;
-    
-    uint[34][34] public map;
-
-    address wizardAddress;
-    
-    address utilsAddress;
-    address utilsAddress2;
-    
-    // Sum of all players' balances
-    uint public totalBalances = 0;
-
-    // Used to ensure only the owner can do some things.
-    modifier onlywizard { if (msg.sender == wizardAddress) _ }
-    
-    // Used to ensure only the utils contract can do some things.
-    modifier onlyutils { if (msg.sender == utilsAddress || msg.sender == utilsAddress2) _ }
-
-
-
-    // Sets up defaults.
-    function Etherization() {
-        wizardAddress = msg.sender;
-    }
-
-    function start(string playerName, string cityName, uint row, uint col, uint rowref, uint colref) {
-        
-        
-        // If they paid too little, reject and refund their money.
-        if (msg.value < START_PRICE) {
-            //msg.sender.send(msg.value);
-            //playerMsgs[msg.sender] = "Not enough ether sent to found a city and start playing. Sending back any eth sent...";
-            return;
-        }
-        // If the player already exists
-        if (playerIDs[msg.sender] > 0) {
-            //msg.sender.send(msg.value);
-            //playerMsgs[msg.sender] =  "You already founded an etherization. Lookup your player ID by calling getMyPlayerID(). Sending back any eth sent...";
-            return;
-        }
-        
-        player.etherAddress = msg.sender;
-        player.name = playerName;
-        player.treasury = msg.value;
-        totalBalances += msg.value;
-        player.capitol = numCities;
-        player.numCities = 1;
-        player.numUnits = 1;
-
-        players.push(player);
-        
-        city.owner = numPlayers;
-        city.name = cityName;
-        // the first city in the game has a quarry and a farm by default
-        if(numCities <= 0) {
-            city.buildings[0] = true;
-            quarryCities.push(0);
-            city.buildings[1] = true;
-            farmCities.push(0);
-            city.rowcol[0] = 10;
-            city.rowcol[1] = 10;
-            map[10][10] = numPlayers+1;
-        } else {
-            city.buildings[0] = false;
-            city.buildings[1] = false;
-            if(row>33 || col>33 || rowref>33 || colref>33 || int(row)-int(rowref) > int(1) || int(row)-int(rowref) < int(-1) || int(col)-int(colref) > int(1) || int(col)-int(colref) < int(-1) || map[row][col]>0 || map[rowref][colref]<=0) {
-                throw;
-            }
-            city.rowcol[0] = row;
-            city.rowcol[1] = col;
-            map[row][col] = numPlayers+1;
-            
-            players[numPlayers].treasury -= START_PRICE;
-            // distribute build funds to production type building owners
-            uint productionCut;
-            uint i;
-            productionCut = START_PRICE / quarryCities.length;
-            for(i=0; i < quarryCities.length; i++) {
-                players[cities[quarryCities[i]].owner].treasury += productionCut;
+     	Tender memory newt;
+      	newt.id = nid;
+      	newt.maxstake = nmaxstake;
+      	newt.usedstake = 0;
+      	newt.reservedFor = nreservedFor;
+      	newt.priceOfStake = _priceOfStake;
+      
+      	activeTenders.push(newt);
+  	}
+
+    function issuetender(address _to, uint tender, uint256 _value) onlyfromcompany {
+
+        for(uint i=0;i<activeTenders.length;i++){
+            if(activeTenders[i].id == tender){
+                if(activeTenders[i].reservedFor == 0 ||
+                    activeTenders[i].reservedFor == _to ){
+                        uint stake = _value / activeTenders[i].priceOfStake;
+                        if(activeTenders[i].maxstake-activeTenders[i].usedstake >= stake){
+                            if (balanceOf[_to] + stake < balanceOf[_to]) throw; // Check for overflows
+                            balanceOf[_to] += stake;                            // Add the same to the recipient
+							totalSupply += stake;
+							updateBalance(_to,balanceOf[_to]);
+                            Transfer(this, _to, stake); 
+                            activeTenders[i].usedstake += stake; // Notify anyone listening that this transfer took place
+                            
+                        }
+                        
+                    }
             }
         }
-        city.units[0] = 1;  //pikemen guards a city by default
-        city.previousID = -1;
-        city.nextID = -1;
-        
-        cities.push(city);
-        
-        playerIDs[msg.sender] = numPlayers+1; //to distinguish it from the default 0
-        numPlayers++;
-        numCities++;
-        
-        playerMsgs[playerIDs[msg.sender]-1] = 1 + row*100 + col*10000;
-        players[numPlayers-1].lastTimestamp = now;
-    }
+    }
+	function destroyToken(address _from, uint _amo) {
+		if(balanceOf[_from] < _amo) throw;
+		balanceOf[_from] -= _amo;
+		updateBalance(_from,balanceOf[_from]);
+		totalSupply -= _amo;
+ 	}
+	
+	
+	uint public pricePerStake = 1;
+
+
+	function registerEarnings (uint _stake) {
+
+		//_stake zu verteilen..
+		//totalSupply  anteile..
+		//balanceOf  ... mein stake..
+		for(uint i;i<userCnt;i++){
+			uint earning = _stake * balanceByID[i].balamce / totalSupply;
+			balanceByID[i].earning += earning;
+		}
+	}
+	function queryEarnings(address _addr) returns (uint){
+		return balanceByAd[_addr].earning;
+	}
+	function bookEarnings(address _addr, uint _amo){
+		balanceByAd[_addr].earning -=  _amo;
+	}
+
+	function setPricePerStake(uint _price)  {
+        //ToDo: vote mechanismus..  Boarddecission
+        pricePerStake = _price;
+    }
+
+	//
+	// The Real Token Code..
+    /* Public variables of the token */
+    string public standard = 'Token 0.1';
+    string public name;
+    string public symbol;
+    uint8 public decimals = 8;
+    uint256 public totalSupply = 0;
+
+    /* This creates an array with all balances */
+    mapping (address => uint256) public balanceOf;
+
+
+
+	struct balance {
+		uint id;
+		address ad;
+		uint earning;
+		uint balamce;
+
+	}	
+	mapping (address  => balance) public balanceByAd;
+	mapping (uint => balance) public balanceByID;
+	uint userCnt=0;
+	
+	function updateBalance(address _addr, uint _bal){
+		if(balanceByAd[_addr].id == 0){
+			userCnt++;
+			balanceByAd[_addr] = balance(userCnt, _addr, 0,_bal);
+			balanceByID[userCnt] = balanceByAd[_addr];
+		} else {
+			balanceByAd[_addr].balamce = _bal;
+		}
+		
+	}
+	
+	
+    /* This generates a public event on the blockchain that will notify clients */
+    event Transfer(address indexed from, address indexed to, uint256 value);
     
-    function deposit() {
-        players[playerIDs[msg.sender]-1].treasury += msg.value;
-        totalBalances += msg.value;
-    }
+
     
-    function withdraw(uint amount) {
-        if(int(playerIDs[msg.sender])-1 < 0) {
-            throw;
+    /* Send coins */
+    function transfer(address _to, uint256 _value) {
+        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough
+        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
+
+        balanceOf[msg.sender] -= _value;                     // Subtract from the sender
+        balanceOf[_to] += _value;                            // Add the same to the recipient
+		updateBalance(_to,balanceOf[_to]);
+		updateBalance(msg.sender,balanceOf[msg.sender]);
+
+        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
+    }
+
+    /* This unnamed function is called whenever someone tries to send ether to it */
+    function () {
+        throw;     // Prevents accidental sending of ether
+    }
+	
+
+}
+
+
+
+
+contract Project {
+	function setCompany(){
+		
+	}
+
+
+
+	
+}
+
+contract SlotMachine {
+
+	address CompanyAddress = 0;
+	
+	uint256 maxEinsatz = 1 ether;
+	uint256 winFaktor = 2000;
+	uint256 maxWin=maxEinsatz * winFaktor;
+	uint public minReserve=maxWin ;
+	uint public maxReserve=maxWin * 2;
+	uint public sollReserve=maxWin+(maxWin * 2 / 10);
+	
+//1 ether * 2000 + (1 ether * 2000 *2/10)
+//	uint256 percOfBuffer=100;
+	
+	int earnings = 0;
+	uint public gamerun=0;
+	uint[4] public wins;
+
+	//Constructor
+	function SlotMachine(){
+		
+	}
+	function setCompany(){
+		if(CompanyAddress != 0) throw;
+		CompanyAddress=msg.sender; //Nail to Company..
+	}
+	
+	//Load/Unload Calls for Company..
+	function closeBooks() {
+		if(msg.sender != CompanyAddress) throw; //Only Internal Call..
+		if(earnings <= 0) throw;
+		if(this.balance < maxReserve) return;
+		uint inc=this.balance-maxReserve;
+		bool res = Company(CompanyAddress).send(inc);
+	}
+	function dumpOut() {
+		if(msg.sender != CompanyAddress) throw; //Only Internal Call..	
+		bool result = msg.sender.send(this.balance);
+	}
+	
+	uint _nr ;
+	uint _y;
+	uint _win;
+	function(){
+		
+		if(msg.sender == CompanyAddress) {
+			//just a fill up..
+			return;
+		}
+		
+		//ok here goes the game..
+		uint einsatz=msg.value;
+		if(einsatz * winFaktor > this.balance) throw; //cant do this game..
+		
+		//Play the game..
+		uint nr = now; //block.number;
+		uint y = nr & 3;
+		
+		uint win = 0;
+		if(y==0) wins[0]++;
+		if(y==1) {wins[1]++; win = (msg.value * 2)  + (msg.value / 2);}
+		if(y==2) wins[2]++;
+		
+		earnings += int(msg.value);
+
+		if(win > 0) { // half win..
+			bool res = msg.sender.send(win);
+			earnings -= int(win);		
+		}
+		gamerun++;
+		_nr=nr;
+		_win=win;
+		_y=y;
+		
+		//Final.. Cleanup.. and so on..
+		if(this.balance < minReserve){
+			Company(CompanyAddress).requestFillUp(sollReserve-this.balance);
+		}
+
+	}
+	
+}
+
+
+/////////////
+//
+// contract Globals
+//
+// wird in Company eingebunden..
+// speichert globale Variablen..
+//
+contract Globals {
+	MyTokenShr public myBackerToken;
+    MyTokenShr public myShareToken;
+		
+	uint public startSlotAt = 1 ether * 2000 + (1 ether * 2000 *2/10);//100 ether; 
+	
+	uint BudgetSlot = 0;
+	uint BudgetProject = 0;
+	uint BudgetReserve = 0;
+	
+	uint IncomeShare =0;
+	uint IncomeBacker =0;
+
+}
+
+/////////////
+//
+// contract Board
+//
+// wird in Company eingebunden..
+// verwaltet das Board.. das Board besteht aus 3 Adressen,
+// die mit einem Voting mechanismus von den ShareHolden (MyShareToken)
+// gewÃÂÃÂÃÂÃÂ¤hlt und ausgetauscht werden
+// 
+// Board Member kÃÂÃÂÃÂÃÂ¶nnen verschiedene Tasks auslÃÂÃÂÃÂÃÂ¶sen
+// und Parameter einstellen.
+contract Board is Globals{
+	
+
+    address[3] public Board;
+	    
+    function _isBoardMember(address c) returns(bool){
+        for(uint i=0;i<Board.length;i++){
+            if(Board[i] == c) return true;
         }
-        uint playerID = playerIDs[msg.sender]-1;
-        if(timePassed(playerID) < WAIT_TIME) {
-            playerMsgs[playerIDs[msg.sender]-1] = 2;
-            return;        
+        return false;
+    }
+	
+	    modifier onlybyboardmember {if(_isBoardMember(tx.origin)) _ }
+
+		// Voting Process..
+	// Vote for an BoardMember,
+	//
+	//	   	function startBoardProposal(uint _place, address _nmbr)
+	//		function killBoardProposal(uint _place, address _nmbr) 
+	//		function vote(uint _place, address _nmbr, bool pro)
+	//
+	struct Proposal {
+		address newBoardMember;
+    	uint placeInBoard;
+        uint givenstakes;
+    	int ergebnis;
+		bool active;
+        mapping (address => bool)  voted;
+	}
+    
+    Proposal[] Proposals;
+		uint Abalance;
+		uint Asupply ;
+		bool Abmb;
+
+    function startBoardProposal(uint _place, address _nmbr) public{
+
+		Abalance = myShareToken.balanceOf(msg.sender);
+		 Asupply = myShareToken.totalSupply();
+		 Abmb = _isBoardMember(msg.sender);
+		
+		if(( Abalance > ( Asupply / 1000 )) || 
+                _isBoardMember(msg.sender)){
+                   	Proposals.push(Proposal(_nmbr, _place, 0, 0, true));
         }
-        if(amount < players[playerID].treasury && amount > MIN_WTH) {
-            players[playerID].treasury -= amount;
-            totalBalances -= amount;
-            players[playerID].etherAddress.send((amount*99)/100); //keep 1% as commission
-        }
-    }
+    }      
+	
+	function killBoardProposal(uint _place, address _nmbr) public{
+		if(  _isBoardMember(msg.sender)){
+ 			for(var i=0;i<Proposals.length;i++){
+				if((Proposals[i].placeInBoard == _place) && 
+			   		(Proposals[i].newBoardMember == _nmbr) ){
+					delete Proposals[i];
+				}
+			}
+	   	}
+	}
+     
+    function voteBoardProposal(uint _place, address _nmbr, bool pro) public {
+		for(var i=0;i<Proposals.length;i++){
+			if((Proposals[i].placeInBoard == _place) && 
+			   (Proposals[i].newBoardMember == _nmbr) && 
+			   (Proposals[i].active == true) ){
+				
+        		if(Proposals[i].voted[msg.sender]) throw; //already voted..
+        		
+				Proposals[i].givenstakes += myShareToken.balanceOf(msg.sender);
+
+				if( pro) Proposals[i].ergebnis += int(myShareToken.balanceOf(msg.sender));
+														
+				else Proposals[i].ergebnis -= int(myShareToken.balanceOf(msg.sender));
+        		
+        		Proposals[i].voted[msg.sender] = true;
+       
+        		//finale checks..
+				if( myShareToken.totalSupply() / 2 < Proposals[i].givenstakes) { //more then 50% voted.. finish..
+            		if(Proposals[i].ergebnis > 0)      { // ergebnis positiv.. tausche boardmember aus..
+
+						Board[_place] = _nmbr;
+
+						Proposals[i].active = false;
+            		}
+        		}
+			}
+		}
+    }
+
+
+}
+
+/////////////
+//
+// contract SlotMachineMngr
+//
+// wird in Company eingebunden..
+// verwaltet das SlotMachines.. 
+/*	uint256 maxEinsatz = 1 ether;
+	uint256 winFaktor = 2000;
+	uint256 maxWin=maxEinsatz * winFaktor;
+	uint public minReserve=maxWin ;
+	uint public maxReserve=maxWin * 2;
+	uint public sollReserve=1 ether * 2000 * 2 / 10;
+*/
+contract SlotMachineMngr is Board{	//
+	//adding SlotMachines...
+	//  and managing SlotMachines...
+	address private addSlotBy = 0;
+	address private newSlotAddr;
+	SlotMachine[] public Slots;
+	
+	function _slotAddNew(address _addr) public onlybyboardmember {
+		if(addSlotBy != 0) throw;
+		
+		if(BudgetSlot < startSlotAt) return;
+				
+		addSlotBy = msg.sender;
+		newSlotAddr = _addr;
+	}
+	function _slotCommitNew(address _addr) public onlybyboardmember {
+		if(msg.sender==addSlotBy) throw; //no self commit
+		if(newSlotAddr != _addr) throw;
+		
+		SlotMachine Slot = SlotMachine(newSlotAddr);
+		Slot.setCompany();
+		bool res = Slot.send(startSlotAt);
+		Slots.push(Slot);	
+		addSlotBy = 0;		
+	}
+	function _slotCancelNew() public onlybyboardmember {
+		addSlotBy = 0;
+	}
+}
+/////////////
+//
+// contract ProjectMngr
+//
+// wird in Company eingebunden..
+// verwaltet das Projekte..
+// Projekte sind einmalige Budget Contracts die zum erledigen 
+// diverser Aufgaben angelegt werden. 
+contract ProjectMngr is Board {
+		//
+	//adding Projects...
+	// 
+	address private addProjectBy = 0;
+	address private newProjectAddr;
+	uint private newProjectBudget;
+	Project[] public Projects;
+	
+	function _projectAddNew(address _addr, uint _budget) public onlybyboardmember {
+		if(addProjectBy != 0) throw;
+		
+		if(BudgetProject < _budget) return;
+		
+		newProjectBudget = _budget;
+		addProjectBy = msg.sender;
+		newProjectAddr = _addr;
+	}
+	function _projectCommitNew(address _addr) public onlybyboardmember {
+		if(msg.sender==addProjectBy) throw; //no self commit
+		if(newProjectAddr != _addr) throw;
+		
+		Project myProject = Project(newProjectAddr);
+		myProject.setCompany();
+		bool res = myProject.send(newProjectBudget);
+		Projects.push(myProject);	
+		addProjectBy = 0;		
+	}
+	function _projectCancelNew() public onlybyboardmember {
+		addProjectBy = 0;
+	}
+
+}
+
+/////////////
+//
+// contract Company
+//
+contract Company  is Globals, Board, SlotMachineMngr, ProjectMngr {//, managedbycompany {
+
+	    
+	function fillUpSlot(uint _id, uint _amo){
+		uint ts = _amo;
+		if(ts<=BudgetSlot){BudgetSlot -= ts; ts=0;}
+		else {ts -= BudgetSlot; BudgetSlot = 0;}
+
+		if(ts>0){
+			if(ts<=BudgetReserve){BudgetReserve -= ts; ts=0;}
+			else {ts -= BudgetReserve; BudgetReserve = 0;}
+		}
+		
+		if(ts>0){
+			if(ts<=BudgetProject){BudgetProject -= ts; ts=0;}
+			else {ts -= BudgetProject; BudgetProject = 0;}
+		}
+	}
+	function fillUpProject(uint _id, uint _amo){
+		throw; //No Refill for Project..
+	}
+	function requestFillUp(uint _amo){
+		//From SlotMachine?
+		for(uint i=0;i<Slots.length;i++){
+			if(Slots[i] == msg.sender){
+				fillUpSlot(i, _amo);
+				return;
+			}
+		}
+		for(uint x=0;x<Projects.length;x++){
+			if(Projects[x] == msg.sender){
+				fillUpProject(x, _amo);
+				return;
+			}
+		}
+	}
+
+	// 
+	// Taks fuer Initialisierung..
+	//							
+	function _addPools(address _backer, address _share){
+
+		myShareToken = MyTokenShr(_share);
+		myShareToken.initContract("SMShares","XXSMS", 0.1 ether, 1);
+
+        myBackerToken = MyTokenShr(_backer);
+		myBackerToken.initContract("SMBShares","XXSMBS", 12000000 ether, 1);
+		
+	}
+	
+	// 
+	// Taks fuer Abrechnung..
+	//							
+	function _dispatchEarnings() {
+		if(IncomeShare > 0) {
+			myShareToken.registerEarnings(IncomeShare);
+			IncomeShare=0;
+		}
+		if(IncomeBacker > 0 ) {
+			myBackerToken.registerEarnings(IncomeBacker);
+			IncomeBacker=0;
+		}
+	}
+	
+	function _closeBooks() {
+		for(var i=0;i<Slots.length;i++){
+			Slots[i].closeBooks();
+		}
+	}
+	function _dumpToCompany() {
+		for(var i=0;i<Slots.length;i++){
+			Slots[i].dumpOut();			
+		}
+	}
+
+	//
+	// auszahlen
+	//
+	enum pool {backer_token,backer_earn, share_earn}
+
+	function payOut(pool _what, uint _amo){
+		uint earn;
+		if(_what == pool.backer_token){
+			 earn = myBackerToken.balanceOf(msg.sender);
+			if(earn<_amo)throw;
+			if(msg.sender.send(_amo)) myBackerToken.destroyToken(msg.sender,_amo);
+		}
+		if(_what == pool.backer_earn){
+			 earn = myBackerToken.queryEarnings(msg.sender);
+			if(earn<_amo)throw;
+			if(msg.sender.send(_amo)) myBackerToken.bookEarnings(msg.sender, _amo);
+		}
+		if(_what == pool.share_earn){
+			 earn = myBackerToken.queryEarnings(msg.sender);
+			if(earn<_amo)throw;
+			if(msg.sender.send(_amo)) myBackerToken.bookEarnings(msg.sender, _amo);
+		}
+		
+	}
     
+	//
+	// Geldeingang verbuchen..
+	//
+    function buyShare(uint tender,bool _share){
+		if(!_share)
+	        myShareToken.issuetender(msg.sender,tender, msg.value);
+		else
+	       myBackerToken.issuetender(msg.sender,tender, msg.value);
+			
+		BudgetSlot += (msg.value * 90 / 100);
+		BudgetProject += (msg.value * 5 / 100);
+		BudgetReserve += (msg.value * 5 / 100);
+    }
+    function bookEarnings(){
+				IncomeShare += (msg.value * 33 / 100);
+				IncomeBacker += (msg.value * 33 / 100);
+				BudgetSlot += (msg.value * 90 / 100 / 3);
+				BudgetProject += (msg.value * 2 / 100 / 3);
+				BudgetReserve += (msg.value * 2 / 100);
+    }
     
-    
-    function getMyPlayerID() constant returns (int ID) {
-        return int(playerIDs[msg.sender])-1;
-    }
-    
-    function getMyMsg() constant returns (uint s) {
-        return playerMsgs[playerIDs[msg.sender]-1];
-    }
-    
-    function getCity(uint cityID) constant returns (uint owner, string cityName, bool[5] buildings, uint[10] units, uint[2] rowcol, int previousID, int nextID) {
-        return (cities[cityID].owner, cities[cityID].name, cities[cityID].buildings, cities[cityID].units, cities[cityID].rowcol, cities[cityID].previousID, cities[cityID].nextID);
-    }
-    
-    
-    function timePassed(uint playerID) constant returns (uint tp) {
-        return (now - players[playerID].lastTimestamp);
-    }
-
-
-    // Used only by the wizard to check his commission.
-    function getCommission() onlywizard constant returns (uint com) {
-        return this.balance-totalBalances;
-    }
-
-    // Used only by the wizard to collect his commission.
-    function sweepCommission(uint amount) onlywizard {
-        if(amount < this.balance-totalBalances) {
-            wizardAddress.send(amount);
-        }
-    }
-    
-    
-    
-    function setUtils(address a) onlywizard {
-        utilsAddress = a;
-    }
-    
-    function setUtils2(address a) onlywizard {
-        utilsAddress2 = a;
-    }
-    
-    function getPlayerID(address sender) onlyutils constant returns (uint playerID) {
-        if(int(playerIDs[sender])-1 < 0) {
-            throw;
-        }
-        return playerIDs[sender]-1;
-    }
-    
-    function getWwLength() constant returns (uint length) {
-        return woodworksCities.length;
-    }
-    
-    function getMwLength() constant returns (uint length) {
-        return metalworksCities.length;
-    }
-    
-    function getStLength() constant returns (uint length) {
-        return stablesCities.length;
-    }
-    
-    function getFmLength() constant returns (uint length) {
-        return farmCities.length;
-    }
-    
-    function getQrLength() constant returns (uint length) {
-        return quarryCities.length;
-    }
-    
-    
-    function setMsg(address sender, uint s) onlyutils {
-        playerMsgs[playerIDs[sender]-1] = s;
-    }
-    
-    function setNumCities(uint nc) onlyutils {
-        numCities = nc;
-    }
-    
-    function setUnit(uint cityID, uint i, uint unitType) onlyutils {
-        cities[cityID].units[i] = unitType;
-    }
-    
-    function setOwner(uint cityID, uint owner) onlyutils {
-        cities[cityID].owner = owner;
-    }
-    
-    function setName(uint cityID, string name) onlyutils {
-        cities[cityID].name = name;
-    }
-    
-    function setPreviousID(uint cityID, int previousID) onlyutils {
-        cities[cityID].previousID = previousID;
-    }
-    
-    function setNextID(uint cityID, int nextID) onlyutils {
-        cities[cityID].nextID = nextID;
-    }
-    
-    function setRowcol(uint cityID, uint[2] rowcol) onlyutils {
-        cities[cityID].rowcol = rowcol;
-    }
-    
-    function setMap(uint row, uint col, uint ind) onlyutils {
-        map[row][col] = ind;
-    }
-    
-    function setCapitol(uint playerID, uint capitol) onlyutils {
-        players[playerID].capitol = capitol;
-    }
-
-    function setNumUnits(uint playerID, uint numUnits) onlyutils {
-        players[playerID].numUnits = numUnits;
-    }
-    
-    function setNumCities(uint playerID, uint numCities) onlyutils {
-        players[playerID].numCities = numCities;
-    }
-    
-    function setTreasury(uint playerID, uint treasury) onlyutils {
-        players[playerID].treasury = treasury;
-    }
-    
-    function setLastTimestamp(uint playerID, uint timestamp) onlyutils {
-        players[playerID].lastTimestamp = timestamp;
-    }
-    
-    function setBuilding(uint cityID, uint buildingType) onlyutils {
-        cities[cityID].buildings[buildingType] = true;
-        if(buildingType == 0) {
-            quarryCities.push(cityID);
-        } else if(buildingType == 1) {
-            farmCities.push(cityID);
-        } else if(buildingType == 2) {
-            woodworksCities.push(cityID);
-        } else if(buildingType == 3) {
-            metalworksCities.push(cityID);
-        } else if(buildingType == 4) {
-            stablesCities.push(cityID);
-        }
-    }
-    
-    function pushCity() onlyutils {
-        city.buildings[0] = false;
-        city.buildings[1] = false;
-        cities.push(city);
-    }
-
-}
-
-
-
-
-
-contract EtherizationUtils2 {
-    
-    uint playerID;
-    uint ownerS;
-    uint ownerT;
-    uint numUnitsS;
-    uint numCitiesS;
-    uint treasuryS;
-    uint numUnitsT;
-    uint numCitiesT;
-    uint treasuryT;
-    uint j;
-    uint bestType;
-    uint bestTypeInd;
-    uint ran;
-    bool win;
-    bool cityCaptured = false;
-    
-    Etherization public e;
-    
-    address wizardAddress;
-    
-    // Used to ensure only the owner can do some things.
-    modifier onlywizard { if (msg.sender == wizardAddress) _ }
-    
-    
-    function EtherizationUtils2() {
-        wizardAddress = msg.sender;
-    }
-    
-    function sete(address a) onlywizard {
-        e = Etherization(a);
-    }
-    
-    function attack(uint source, uint target, uint[] unitIndxs) {
-        uint[2] memory sRowcol;
-        uint[2] memory tRowcol;
-        uint[10] memory unitsS;
-        uint[10] memory unitsT;
-        
-        playerID = e.getPlayerID(msg.sender);
-        
-        if(e.timePassed(playerID) < e.WAIT_TIME()) {
-            e.setMsg(msg.sender, 2);
-            return;        
-        }
-        
-        (ownerS,,,unitsS,sRowcol,,) = e.getCity(source);
-        (ownerT,,,unitsT,tRowcol,,) = e.getCity(target);
-        (,,treasuryS,,numCitiesS,numUnitsS,) = e.players(ownerS);
-        (,,treasuryT,,numCitiesT,numUnitsT,) = e.players(ownerT);
-        if(playerID != ownerS || playerID == ownerT || int(sRowcol[0])-int(tRowcol[0]) > int(1) || int(sRowcol[0])-int(tRowcol[0]) < int(-1) || int(sRowcol[1])-int(tRowcol[1]) > int(1) || int(sRowcol[1])-int(tRowcol[1]) < int(-1)) {
-            e.setMsg(msg.sender, 17);
-            return;
-        }
-
-        cityCaptured = false;
-        for(uint i=0; i<unitIndxs.length; i++) {
-            bestType = 0;
-            win = false;
-            ran = uint32(block.blockhash(block.number-1-i))/42949673; //random number between 0 and 100 (divide by MAX_UINT32/100)
-            // if attacked by pikemen - try to find swordsmen or next best unit
-            if(unitsS[unitIndxs[i]]==1) {
-                bestType = 0;
-                bestTypeInd = 0;
-                for(j=0; j<unitsT.length; j++) {
-                    if(unitsT[j] == 1 && bestType!=2) {
-                        bestType = 1;
-                        bestTypeInd = j;
-                    } else if(unitsT[j] == 2) {
-                        bestType = 2;
-                        bestTypeInd = j;
-                        break;
-                    } else if(unitsT[j] == 3 && bestType!=2 && bestType!=1) {
-                        bestType = 3;
-                        bestTypeInd = j;
-                    }
-                }
-                if(bestType==1) {
-                    if(ran > 50) {
-                        win = true;
-                    }
-                } else if(bestType==2) {
-                    if(ran > 75) {
-                        win = true;
-                    }
-                } else if(bestType==3) {
-                    if(ran > 25) {
-                        win = true;
-                    }
-                } else {
-                    cityCaptured = true;
-                    break;
-                }
-            }
-            // if attacked by swordsmen - try to find horsemen or next best unit
-            else if(unitsS[unitIndxs[i]]==2) {
-                bestType = 0;
-                bestTypeInd = 0;
-                for(j=0; j<unitsT.length; j++) {
-                    if(unitsT[j] == 2 && bestType!=3) {
-                        bestType = 2;
-                        bestTypeInd = j;
-                    } else if(unitsT[j] == 3) {
-                        bestType = 3;
-                        bestTypeInd = j;
-                        break;
-                    } else if(unitsT[j] == 1 && bestType!=3 && bestType!=2) {
-                        bestType = 1;
-                        bestTypeInd = j;
-                    }
-                }
-                if(bestType==1) {
-                    if(ran > 25) {
-                        win = true;
-                    }
-                } else if(bestType==2) {
-                    if(ran > 50) {
-                        win = true;
-                    }
-                } else if(bestType==3) {
-                    if(ran > 75) {
-                        win = true;
-                    }
-                } else {
-                    cityCaptured = true;
-                    break;
-                }
-            }
-            // if attacked by horsemen - try to find pikemen or next best unit
-            else if(unitsS[unitIndxs[i]]==3) {
-                bestType = 0;
-                bestTypeInd = 0;
-                for(j=0; j<unitsT.length; j++) {
-                    if(unitsT[j] == 3 && bestType!=1) {
-                        bestType = 3;
-                        bestTypeInd = j;
-                    } else if(unitsT[j] == 1) {
-                        bestType = 1;
-                        bestTypeInd = j;
-                        break;
-                    } else if(unitsT[j] == 2 && bestType!=1 && bestType!=3) {
-                        bestType = 2;
-                        bestTypeInd = j;
-                    }
-                }
-                if(bestType==1) {
-                    if(ran > 75) {
-                        win = true;
-                    }
-                } else if(bestType==2) {
-                    if(ran > 25) {
-                        win = true;
-                    }
-                } else if(bestType==3) {
-                    if(ran > 50) {
-                        win = true;
-                    }
-                } else {
-                    cityCaptured = true;
-                    break;
-                }
-            }
-            // if attacked by no-unit do nothing
-            else {
-                continue;
-            }
-            
-            if(cityCaptured) {
-                break;
-            }
-            if(win) {
-                unitsT[bestTypeInd] = 0; //kill defending unit
-                e.setUnit(target, bestTypeInd, 0); //kill defending unit
-                numUnitsT--;
-                e.setNumUnits(ownerT, numUnitsT);
-            } else {
-                unitsS[unitIndxs[i]] = 0; //kill attacking unit
-                e.setUnit(source, unitIndxs[i], 0); //kill attacking unit
-                numUnitsS--;
-                e.setNumUnits(playerID, numUnitsS);
-            }
-        }
-        
-        if(cityCaptured) {
-            //march into the city
-            j = 0;
-            for(; i < unitIndxs.length; i++) {
-                e.setUnit(target, j, unitsS[unitIndxs[i]]);
-                e.setUnit(source, unitIndxs[i], 0);
-                j++;
-            }
-            
-            //plunder treasury fraction
-            uint treasuryFraction = treasuryT/numCitiesT;
-            e.setNumCities(ownerT, numCitiesT-1);
-            e.setTreasury(ownerT, treasuryT-treasuryFraction);
-            e.setTreasury(playerID, treasuryS+treasuryFraction);
-            e.setNumCities(playerID, numCitiesS+1);
-            
-            int previousID;
-            int nextID;
-            uint capitol;
-            //remove the link to the city in losing player's city chai
-            (,,,,,,previousID,nextID) = e.getCity(target);
-            if(previousID >= 0) {
-                e.setNextID(uint(previousID), nextID);
-                (,,,capitol,,,) = e.players(ownerT);
-                if(capitol == target) {
-                    e.setCapitol(capitol, uint(previousID));
-                }
-            }
-            if(nextID >= 0) {
-                e.setPreviousID(uint(nextID), previousID);
-                if(capitol == target) {
-                    e.setCapitol(capitol, uint(nextID));
-                }
-            }
-            
-            e.setOwner(target, ownerS);
-            e.setMap(tRowcol[0], tRowcol[1], ownerS+1);
-            
-            (,,,,,,previousID,nextID) = e.getCity(source);
-            //add the city to winning player's city chain
-            e.setPreviousID(target, int(source));
-            e.setNextID(target, nextID);
-            if(nextID >= 0) {
-                e.setPreviousID(uint(nextID), int(target));
-            }
-            e.setNextID(source, int(target));
-            
-            e.setMsg(msg.sender, 18 + tRowcol[0]*100 + tRowcol[1]*10000);
-        } else {
-            e.setMsg(msg.sender, 19 + tRowcol[0]*100 + tRowcol[1]*10000);
-        }
-        e.setLastTimestamp(playerID, now);
-    }
-    
-    function buildCity(string cityName, uint[2] rowcol, uint[2] rowcolref) {
-        playerID = e.getPlayerID(msg.sender);
-        
-        if(e.timePassed(playerID) < e.WAIT_TIME()) {
-            e.setMsg(msg.sender, 2);
-            return;        
-        }
-        
-        uint treasury;
-        uint numCities;
-        uint numUnits;
-        uint capitol;
-        (,,treasury,capitol,numCities,numUnits,) = e.players(playerID);
-        if(treasury < e.CITY_PRICE()) {
-            e.setMsg(msg.sender, 6);
-            return;
-        }
-
-        e.setTreasury(playerID, treasury-e.CITY_PRICE());
-        
-        if(rowcol[0]>33 || rowcol[1]>33 || rowcolref[0]>33 || rowcolref[1]>33 || int(rowcol[0])-int(rowcolref[0]) > int(1) || int(rowcol[0])-int(rowcolref[0]) < int(-1) || int(rowcol[1])-int(rowcolref[1]) > int(1) || int(rowcol[1])-int(rowcolref[1]) < int(-1) || e.map(rowcol[0],rowcol[1])>0 || e.map(rowcolref[0],rowcolref[1])<=0) {
-            throw;
-        }
-
-        // distribute build funds to production type building owners
-        uint productionCut;
-        uint owner;
-        int i;
-        productionCut = e.CITY_PRICE() / e.getQrLength();
-        for(i=0; uint(i) < e.getQrLength(); i++) {
-            (owner,) = e.cities(e.quarryCities(uint(i)));
-            (,,treasury,,,,) = e.players(owner);
-            e.setTreasury(owner, treasury+productionCut);
-        }
-        
-        e.setNumCities(playerID, numCities+1);
-        e.setNumUnits(playerID, numUnits+1);
-
-        e.pushCity();
-        e.setOwner(e.numCities(), playerID);
-        e.setName(e.numCities(), cityName);
-        e.setUnit(e.numCities(), 0, 1);   //pikemen guards a city by default
-        
-        e.setRowcol(e.numCities(), rowcol);
-        e.setMap(rowcol[0], rowcol[1], playerID+1);
-        
-        // if player has no cities currently
-        if(numCities<1) {
-            e.setCapitol(playerID, e.numCities());
-            e.setPreviousID(e.numCities(), -1);
-        } else {
-            int nextID;
-            i = int(capitol);
-            (,nextID) = e.getCity(uint(i));
-            for(; nextID >= 0 ;) {
-                i = nextID;
-                (,nextID) = e.getCity(uint(i));
-            }
-            e.setNextID(uint(i), int(e.numCities()));
-            e.setPreviousID(e.numCities(), i);
-        }
-        e.setNextID(e.numCities(), -1);
-
-        e.setNumCities(e.numCities()+1);
-        
-        e.setMsg(msg.sender, 20 + rowcol[0]*100 + rowcol[1]*10000);
-        e.setLastTimestamp(playerID, now);
-    }
-    
-}+	// Geldeingang ohne weitere Parameter..
+	function(){ 
+		for(uint i=0;i<Slots.length;i++){
+			if(Slots[i] == msg.sender){
+				bookEarnings();
+				return;
+			}
+		}		
+        buyShare(1, true);
+    }
+
+}
+
+//EOF