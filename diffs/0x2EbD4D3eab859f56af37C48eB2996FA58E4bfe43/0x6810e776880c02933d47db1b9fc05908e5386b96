--- 
+++ 
@@ -1,140 +1,151 @@
+pragma solidity 0.4.10;
+
+
+/// @title Abstract token contract - Functions to be implemented by token contracts.
 contract Token {
-    /// Get the total amount of tokens in the system.
-    function totalSupply() constant returns (uint256 total);
+    function transfer(address to, uint256 value) returns (bool success);
+    function transferFrom(address from, address to, uint256 value) returns (bool success);
+    function approve(address spender, uint256 value) returns (bool success);
 
-    /// @param _owner The address from which the balance will be retrieved
-    /// @return The balance
-    function balanceOf(address _owner) constant returns (uint256 balance);
+    // This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions.
+    function totalSupply() constant returns (uint256 supply) {}
+    function balanceOf(address owner) constant returns (uint256 balance);
+    function allowance(address owner, address spender) constant returns (uint256 remaining);
 
-    /// @notice send `_value` token to `_to` from `msg.sender`
-    /// @param _to The address of the recipient
-    /// @param _value The amount of token to be transferred
-    /// @return Whether the transfer was successful or not
-    function transfer(address _to, uint256 _value) returns (bool success);
-
-    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
-    /// @param _from The address of the sender
-    /// @param _to The address of the recipient
-    /// @param _value The amount of token to be transferred
-    /// @return Whether the transfer was successful or not
-    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
-
-    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
-    /// @param _spender The address of the account able to transfer the tokens
-    /// @param _value The amount of wei to be approved for transfer
-    /// @return Whether the approval was successful or not
-    function approve(address _spender, uint256 _value) returns (bool success);
-
-    /// @param _owner The address of the account owning tokens
-    /// @param _spender The address of the account able to transfer the tokens
-    /// @return Amount of remaining tokens allowed to spent
-    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
-
-    event Transfer(address indexed _from, address indexed _to, uint256 _value);
-    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
+    event Transfer(address indexed from, address indexed to, uint256 value);
+    event Approval(address indexed owner, address indexed spender, uint256 value);
 }
 
-contract KittyCoin {
-    struct Receipt {
-        uint units;
-        uint32 activation;
-    }
-    struct Account {
-        uint balance;
-        mapping (uint => Receipt) receipt;
-        mapping (address => uint) allowanceOf;
-    }
-    
-    event Transfer(address indexed from, address indexed to, uint256 value);
-    event Approval(address indexed owner, address indexed spender, uint256 value);
-    event Buyin(address indexed buyer, uint indexed price, uint indexed amount);
-    event Refund(address indexed buyer, uint indexed price, uint indexed amount);
-    event NewTranch(uint indexed price);
-    
-    modifier when_owns(address _owner, uint _amount) { if (accounts[_owner].balance < _amount) return; _; }
-    modifier when_has_allowance(address _owner, address _spender, uint _amount) { if (accounts[_owner].allowanceOf[_spender] < _amount) return; _; }
-    modifier when_have_active_receipt(uint _price, uint _units) { if (accounts[msg.sender].receipt[_price].units < _units || now < accounts[msg.sender].receipt[_price].activation) return; _; }
 
-    function balanceOf(address _who) constant returns (uint) { return accounts[_who].balance; }
-    
-    function transfer(address _to, uint256 _value) when_owns(msg.sender, _value) returns (bool success) {
+/// @title Standard token contract - Standard token interface implementation.
+contract StandardToken is Token {
+
+    /*
+     *  Data structures
+     */
+    mapping (address => uint256) balances;
+    mapping (address => mapping (address => uint256)) allowed;
+    uint256 public totalSupply;
+
+    /*
+     *  Public functions
+     */
+    /// @dev Transfers sender's tokens to a given address. Returns success.
+    /// @param _to Address of token receiver.
+    /// @param _value Number of tokens to transfer.
+    /// @return Returns success of function call.
+    function transfer(address _to, uint256 _value)
+        public
+        returns (bool)
+    {
+        if (balances[msg.sender] < _value) {
+            // Balance too low
+            throw;
+        }
+        balances[msg.sender] -= _value;
+        balances[_to] += _value;
         Transfer(msg.sender, _to, _value);
-        accounts[msg.sender].balance -= _value;
-        accounts[_to].balance += _value;
-    }
-    function transferFrom(address _from, address _to, uint256 _value) when_owns(_from, _value) when_has_allowance(_from, msg.sender, _value) returns (bool success) {
-        Transfer(_from, _to, _value);
-        accounts[_from].allowanceOf[msg.sender] -= _value;
-        accounts[_from].balance -= _value;
-        accounts[_to].balance += _value;
-        return true;
-    }
-    function approve(address _spender, uint256 _value) returns (bool success) {
-        Approval(msg.sender, _spender, _value);
-        accounts[msg.sender].allowanceOf[_spender] += _value;
-        return true;
-    }
-    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
-        return accounts[_owner].allowanceOf[_spender];
-    }
-    
-    /// Simple buyin.
-    function() { buyinInternal(msg.sender, 2 ** 255); }
-
-    /// Extended buyin.
-    function buyin(address _who, uint _maxPrice) { buyinInternal(_who, _maxPrice); }
-
-    function refund(uint _price, uint _units) when_have_active_receipt(_price, _units) when_owns(msg.sender, _units) returns (bool) {
-        Refund(msg.sender, _price, _units);
-        accounts[msg.sender].balance -= _units;
-        totalSupply += _units;
-        accounts[msg.sender].receipt[_price].units -= _units;
-        if (accounts[msg.sender].receipt[_price].units == 0)
-            delete accounts[msg.sender].receipt[_price];
-        if (!msg.sender.send(_units * _price / base))
-            throw;
         return true;
     }
 
-    function buyinInternal(address _who, uint _maxPrice) internal {
-        var leftToSpend = msg.value;
-        while (leftToSpend > 0 && price <= _maxPrice) {
-            // How much the remaining tokens of this tranch cost to buy
-            var maxCanSpend = price * remaining / base;
-            // How much we will spend - the mininum of what's left in the tranch
-            // to buy and what we have remaining
-            var spend = leftToSpend > maxCanSpend ? maxCanSpend : leftToSpend;
-            // The number of units we get for spending that
-            var units = spend * base / price;
+    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.
+    /// @param _from Address from where tokens are withdrawn.
+    /// @param _to Address to where tokens are sent.
+    /// @param _value Number of tokens to transfer.
+    /// @return Returns success of function call.
+    function transferFrom(address _from, address _to, uint256 _value)
+        public
+        returns (bool)
+    {
+        if (balances[_from] < _value || allowed[_from][msg.sender] < _value) {
+            // Balance or allowance too low
+            throw;
+        }
+        balances[_to] += _value;
+        balances[_from] -= _value;
+        allowed[_from][msg.sender] -= _value;
+        Transfer(_from, _to, _value);
+        return true;
+    }
 
-            // Provide tokens and a purchase receipt
-            accounts[msg.sender].balance += units;
-            accounts[msg.sender].receipt[price].units += units;
-            accounts[msg.sender].receipt[price].activation = uint32(now) + refundActivationPeriod;
-            totalSupply += units;
-            Buyin(msg.sender, price, units);
+    /// @dev Sets approved amount of tokens for spender. Returns success.
+    /// @param _spender Address of allowed account.
+    /// @param _value Number of approved tokens.
+    /// @return Returns success of function call.
+    function approve(address _spender, uint256 _value)
+        public
+        returns (bool)
+    {
+        allowed[msg.sender][_spender] = _value;
+        Approval(msg.sender, _spender, _value);
+        return true;
+    }
 
-            // Reduce the amounts remaining
-            leftToSpend -= spend;
-            remaining -= units;
-            
-            // If this is the end of the tranch...
-            if (remaining == 0) {
-                // ...Increment price and reset remaining
-                price += tranchStep;
-                remaining = tokensPerTranch * base;
-                NewTranch(price);
-            }
+    /*
+     * Read functions
+     */
+    /// @dev Returns number of allowed tokens for given address.
+    /// @param _owner Address of token owner.
+    /// @param _spender Address of token spender.
+    /// @return Returns remaining allowance for spender.
+    function allowance(address _owner, address _spender)
+        constant
+        public
+        returns (uint256)
+    {
+        return allowed[_owner][_spender];
+    }
+
+    /// @dev Returns number of tokens owned by given address.
+    /// @param _owner Address of token owner.
+    /// @return Returns balance of owner.
+    function balanceOf(address _owner)
+        constant
+        public
+        returns (uint256)
+    {
+        return balances[_owner];
+    }
+}
+
+
+/// @title Gnosis token contract
+/// @author Stefan George - <stefan.george@consensys.net>
+contract GnosisToken is StandardToken {
+
+    /*
+     *  Token meta data
+     */
+    string constant public name = "Gnosis Token";
+    string constant public symbol = "GNO";
+    uint8 constant public decimals = 18;
+
+    /*
+     *  Public functions
+     */
+    /// @dev Contract constructor function sets dutch auction contract address and assigns all tokens to dutch auction.
+    /// @param dutchAuction Address of dutch auction contract.
+    /// @param owners Array of addresses receiving preassigned tokens.
+    /// @param tokens Array of preassigned token amounts.
+    function GnosisToken(address dutchAuction, address[] owners, uint[] tokens)
+        public
+    {
+        if (dutchAuction == 0)
+            // Address should not be null.
+            throw;
+        totalSupply = 10000000 * 10**18;
+        balances[dutchAuction] = 9000000 * 10**18;
+        Transfer(0, dutchAuction, balances[dutchAuction]);
+        uint assignedTokens = balances[dutchAuction];
+        for (uint i=0; i<owners.length; i++) {
+            if (owners[i] == 0)
+                // Address should not be null.
+                throw;
+            balances[owners[i]] += tokens[i];
+            Transfer(0, owners[i], tokens[i]);
+            assignedTokens += tokens[i];
         }
+        if (assignedTokens != totalSupply)
+            throw;
     }
-    
-    uint public totalSupply;
-    mapping (address => Account) accounts;
-    
-    uint constant base = 1000000;               // tokens are subdivisible by 1000000
-    uint constant tranchStep = 1 finney;        // raise price by 1 finney / tranch
-    uint constant tokensPerTranch = 100;        // 100 tokens per tranch
-    uint public price = 1 finney;               // begin at 1 finney / token
-    uint public remaining = tokensPerTranch * base;
-    uint32 constant refundActivationPeriod = 7 days;
 }