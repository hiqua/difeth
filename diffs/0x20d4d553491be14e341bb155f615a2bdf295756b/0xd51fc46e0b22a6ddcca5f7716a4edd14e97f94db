--- 
+++ 
@@ -1,13 +1,104 @@
-pragma solidity ^0.4.8;
+// Dr. Sebastian Buergel, Validity Labs AG
+pragma solidity ^0.4.11;
 
-/// @title ERC20 Token
-/// @author Melonport AG <team@melonport.com>
-/// @notice Original taken from https://github.com/ethereum/EIPs/issues/20
-/// @notice Checked against integer overflow
-contract ERC20 {
+/**
+ * @title Ownable
+ * @dev The Ownable contract has an owner address, and provides basic authorization control 
+ * functions, this simplifies the implementation of "user permissions". 
+ */
+contract Ownable {
+  address public owner;
+
+
+  /** 
+   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
+   * account.
+   */
+  function Ownable() {
+    owner = msg.sender;
+  }
+
+
+  /**
+   * @dev Throws if called by any account other than the owner. 
+   */
+  modifier onlyOwner() {
+    if (msg.sender != owner) {
+      throw;
+    }
+    _;
+  }
+
+
+  /**
+   * @dev Allows the current owner to transfer control of the contract to a newOwner.
+   * @param newOwner The address to transfer ownership to. 
+   */
+  function transferOwnership(address newOwner) onlyOwner {
+    if (newOwner != address(0)) {
+      owner = newOwner;
+    }
+  }
+
+}
+
+
+
+contract Token {
+    /* This is a slight change to the ERC20 base standard.
+    function totalSupply() constant returns (uint256 supply);
+    is replaced with:
+    uint256 public totalSupply;
+    This automatically creates a getter function for the totalSupply.
+    This is moved to the base contract since public getter functions are not
+    currently recognised as an implementation of the matching abstract
+    function by the compiler.
+    */
+    /// total amount of tokens
+    uint256 public totalSupply;
+
+    /// @param _owner The address from which the balance will be retrieved
+    /// @return The balance
+    function balanceOf(address _owner) constant returns (uint256 balance);
+
+    /// @notice send `_value` token to `_to` from `msg.sender`
+    /// @param _to The address of the recipient
+    /// @param _value The amount of token to be transferred
+    /// @return Whether the transfer was successful or not
+    function transfer(address _to, uint256 _value) returns (bool success);
+
+    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
+    /// @param _from The address of the sender
+    /// @param _to The address of the recipient
+    /// @param _value The amount of token to be transferred
+    /// @return Whether the transfer was successful or not
+    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
+
+    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens
+    /// @param _spender The address of the account able to transfer the tokens
+    /// @param _value The amount of tokens to be approved for transfer
+    /// @return Whether the approval was successful or not
+    function approve(address _spender, uint256 _value) returns (bool success);
+
+    /// @param _owner The address of the account owning tokens
+    /// @param _spender The address of the account able to transfer the tokens
+    /// @return Amount of remaining tokens allowed to spent
+    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
+
+    event Transfer(address indexed _from, address indexed _to, uint256 _value);
+    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
+}
+
+
+
+contract StandardToken is Token {
 
     function transfer(address _to, uint256 _value) returns (bool success) {
-        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
+        //Default assumes totalSupply can't be over max (2^256 - 1).
+        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
+        //Replace the if with this one instead.
+        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
+        if (balances[msg.sender] >= _value && _value > 0) {
             balances[msg.sender] -= _value;
             balances[_to] += _value;
             Transfer(msg.sender, _to, _value);
@@ -16,7 +107,9 @@
     }
 
     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
-        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
+        //same as above. Replace this line with the following if you want to protect against wrapping uints.
+        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
+        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
             balances[_to] += _value;
             balances[_from] -= _value;
             allowed[_from][msg.sender] -= _value;
@@ -36,57 +129,58 @@
     }
 
     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
-        return allowed[_owner][_spender];
+      return allowed[_owner][_spender];
     }
 
     mapping (address => uint256) balances;
+    mapping (address => mapping (address => uint256)) allowed;
+}
 
-    mapping (address => mapping (address => uint256)) allowed;
 
-    uint256 public totalSupply;
 
-    address public owner;
+// wraps non-ERC20-conforming fundraising contracts (aka pure IOU ICO) in a standard ERC20 contract that is immediately tradable and usable via default tools.
+// this is again a pure IOU token but now having all the benefits of standard tokens.
+contract ERC20nator is StandardToken, Ownable {
 
-    event Transfer(address indexed _from, address indexed _to, uint256 _value);
-    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
+    address public fundraiserAddress;
 
-    modifier onlyowner(address _requester) {
-        if (_requester != owner) {
+    uint constant issueFeePercent = 10; // fee in percent that is collected for all paid in funds
+
+    event requestedRedeem(address indexed requestor, uint amount);
+    
+    event redeemed(address redeemer, uint amount);
+
+    // fallback function invests in fundraiser
+    // fee percentage is given to owner for providing this service
+    // remainder is invested in fundraiser
+    function() payable {
+        uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
+
+        // invest 90% into fundraiser
+        if(!fundraiserAddress.send(issuedTokens))
             throw;
-        }
-        _;
+
+        // pay 10% to owner
+        if(!owner.send(msg.value - issuedTokens))
+            throw;
+        
+        // issue tokens by increasing total supply and balance
+        totalSupply += issuedTokens;
+        balances[msg.sender] += issuedTokens;
     }
 
-    event Mint(address indexed _owner, uint256 _value, uint256 _totalSupply);
-    event Burn(address indexed _owner, uint256 _value, uint256 _totalSupply);
-    event ChangeOwner(address indexed _oldOwner, address indexed _newOwner);
-
-    function ERC20() {
-        owner = msg.sender;
+    // allow owner to set fundraiser target address
+    function setFundraiserAddress(address _fundraiserAddress) onlyOwner {
+        fundraiserAddress = _fundraiserAddress;
     }
 
-    function mint(uint _value) onlyowner(msg.sender) {
-        if (balances[owner] + _value < balances[owner]) {
-            // overflow
-            throw;
-        }
-        balances[owner] += _value;
-        totalSupply += _value;
-        Mint(owner, _value, totalSupply);
+    // this is just to inform the owner that a user wants to redeem some of their IOU tokens
+    function requestRedeem(uint amount) {
+        requestedRedeem(msg.sender, amount);
     }
 
-    function burn(uint _value) onlyowner(msg.sender) {
-        if (balances[owner] < _value) {
-            throw;
-        }
-        balances[owner] -= _value;
-        totalSupply -= _value;
-        Burn(owner, _value, totalSupply);
+    // this is just to inform the investor that the owner redeemed some of their IOU tokens
+    function redeem(uint amount) onlyOwner{
+        redeemed(msg.sender, amount);
     }
-
-    function changeOwner(address _owner) onlyowner(msg.sender) {
-        owner = _owner;
-        ChangeOwner(msg.sender, owner);
-    }
-
 }